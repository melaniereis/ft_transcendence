import sqlite3 from 'sqlite3';
import path from 'path';
import { fileURLToPath } from 'url';


sqlite3.verbose();


const __filename = fileURLToPath(import.meta.url);


const __dirname = path.dirname(__filename);


const dbPath = path.join(__dirname, '..' , '..', '..', 'data', 'database.db');


const db = new sqlite3.Database(dbPath, (err) => {
    if (err)
        console.error('Failed to connect to database:', err.message);
    else 
        console.log('Connected to SQLite');
});


db.serialize(() => {
    // USERS - Com campo TEAM corrigido
    db.run(`CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL,
        name TEXT NOT NULL,
        team TEXT NOT NULL,
        display_name TEXT,
        email TEXT UNIQUE,
        avatar_url TEXT DEFAULT '/assets/avatar/default.png',
        online_status INTEGER DEFAULT 0,
        last_seen TEXT DEFAULT CURRENT_TIMESTAMP,
        created_at TEXT DEFAULT CURRENT_TIMESTAMP
    )`);


    // TOURNAMENTS
    db.run(`CREATE TABLE IF NOT EXISTS tournaments (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        team_winner TEXT NOT NULL,
        team_victories INTEGER NOT NULL,
        size INTEGER NOT NULL,
        date_created TEXT DEFAULT CURRENT_TIMESTAMP
    )`);


    // TEAM TABLES
    db.run(`CREATE TABLE IF NOT EXISTS hacktivists (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        members TEXT NOT NULL UNIQUE,
        victories INTEGER DEFAULT 0,
        tournaments_won INTEGER DEFAULT 0,
        defeats INTEGER DEFAULT 0,
        win_rate REAL DEFAULT 0,
        created_at TEXT DEFAULT CURRENT_TIMESTAMP
    )`);


    db.run(`CREATE TABLE IF NOT EXISTS bug_busters (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        members TEXT NOT NULL UNIQUE,
        victories INTEGER DEFAULT 0,
        tournaments_won INTEGER DEFAULT 0,
        defeats INTEGER DEFAULT 0,
        win_rate REAL DEFAULT 0,
        created_at TEXT DEFAULT CURRENT_TIMESTAMP
    )`);


    db.run(`CREATE TABLE IF NOT EXISTS logic_league (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        members TEXT NOT NULL UNIQUE,
        victories INTEGER DEFAULT 0,
        tournaments_won INTEGER DEFAULT 0,
        defeats INTEGER DEFAULT 0,
        win_rate REAL DEFAULT 0,
        created_at TEXT DEFAULT CURRENT_TIMESTAMP
    )`);


    db.run(`CREATE TABLE IF NOT EXISTS code_alliance (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        members TEXT NOT NULL UNIQUE,
        victories INTEGER DEFAULT 0,
        tournaments_won INTEGER DEFAULT 0,
        defeats INTEGER DEFAULT 0,
        win_rate REAL DEFAULT 0,
        created_at TEXT DEFAULT CURRENT_TIMESTAMP
    )`);


    // USER STATS 
    db.run(`CREATE TABLE IF NOT EXISTS user_stats (
        user_id INTEGER PRIMARY KEY,
        matches_played INTEGER DEFAULT 0,
        matches_won INTEGER DEFAULT 0,
        matches_lost INTEGER DEFAULT 0,
        points_scored INTEGER DEFAULT 0,
        points_conceded INTEGER DEFAULT 0,
        total_play_time INTEGER DEFAULT 0,
        win_rate REAL DEFAULT 0.0,
        tournaments_played INTEGER DEFAULT 0,
        tournaments_won INTEGER DEFAULT 0,
        created_at TEXT DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id)
    )`);


    // GAMES
    db.run(`CREATE TABLE IF NOT EXISTS games (
        game_id INTEGER PRIMARY KEY AUTOINCREMENT,
        player1_id INTEGER NOT NULL,
        player2_id INTEGER NOT NULL,
        max_games INTEGER NOT NULL,
        score_player1 INTEGER DEFAULT 0,
        score_player2 INTEGER DEFAULT 0,
        time_started TEXT NOT NULL,
        time_ended TEXT,
        winner_id INTEGER,
        match_duration INTEGER DEFAULT 0,
        date_played TEXT DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (player1_id) REFERENCES users(id),
        FOREIGN KEY (player2_id) REFERENCES users(id),
        FOREIGN KEY (winner_id) REFERENCES users(id)
    )`);


    // SESSIONS
    db.run(`CREATE TABLE IF NOT EXISTS sessions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        token TEXT NOT NULL UNIQUE,
        created_at TEXT DEFAULT CURRENT_TIMESTAMP,
        expires_at TEXT,
        FOREIGN KEY(user_id) REFERENCES users(id)
    )`);


    // FRIENDSHIPS
    db.run(`CREATE TABLE IF NOT EXISTS friendships (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        friend_id INTEGER NOT NULL,
        status TEXT CHECK(status IN ('pending','accepted','blocked')) DEFAULT 'pending',
        created_at TEXT DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(user_id, friend_id),
        FOREIGN KEY(user_id) REFERENCES users(id),
        FOREIGN KEY(friend_id) REFERENCES users(id)
    )`);


    // MATCH HISTORY
    db.run(`CREATE TABLE IF NOT EXISTS match_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        game_id INTEGER NOT NULL,
        user_id INTEGER NOT NULL,
        opponent_id INTEGER NOT NULL,
        user_score INTEGER NOT NULL,
        opponent_score INTEGER NOT NULL,
        result TEXT CHECK(result IN ('win','loss')) NOT NULL,
        duration INTEGER DEFAULT 0,
        date_played TEXT DEFAULT CURRENT_TIMESTAMP
    )`);


    console.log('游늶 Database tables created successfully');
});


export default db;

//routes/authRoutes.ts
import { FastifyRequest, FastifyReply, FastifyInstance } from 'fastify';
import { registerUser, loginUser, verifyToken } from '../services/authService.js';


interface RegisterRequest {
    username: string;
    password: string;
    name: string;
    team: string;
    display_name?: string;
    email?: string;
}


interface LoginRequest {
    username: string;
    password: string;
}


export async function authRoutes(fastify: FastifyInstance) {
    // User Registration
    fastify.post('/api/register', async (req: FastifyRequest, reply: FastifyReply) => {
        try {
            const { username, password, name, team, display_name, email } = req.body as RegisterRequest;


            // Simple validation
            if (!username || !password || !name || !team) {
                return reply.status(400).send({ 
                    error: 'Campos obrigat칩rios: username, password, name, team' 
                });
            }


            const result = await registerUser({ 
                username, 
                password, 
                name, 
                team,
                display_name,
                email 
            });
            
            reply.send({ success: true, userId: result.id });
        } 
        catch (err: any) {
            console.error('Registration error:', err);
            reply.status(400).send({ 
                error: 'Falha no registo', 
                details: err.message 
            });
        }
    });


    // Login
    fastify.post('/api/login', async (req: FastifyRequest, reply: FastifyReply) => {
        try {
            const { username, password } = req.body as LoginRequest;


            if (!username || !password) {
                return reply.status(400).send({ 
                    error: 'Username e password s칚o obrigat칩rios' 
                });
            }


            const result = await loginUser(username, password);
            if (!result) {
                return reply.status(401).send({ error: 'Credenciais inv치lidas' });
            }


            reply.send({ token: result.token, message: 'Login bem-sucedido' });
        }
        catch (err: any) {
            console.error('Login error:', err);
            reply.status(500).send({ error: 'Erro interno no servidor' });
        }
    });


    // Route protected for testing token verification
    fastify.get('/api/protected', async (req: FastifyRequest, reply: FastifyReply) => {
        const authHeader = req.headers.authorization;


        if (!authHeader) {
            return reply.status(401).send({ error: 'Header de autoriza칞칚o em falta' });
        }


        const token = authHeader.split(' ')[1];
        if (!token) {
            return reply.status(401).send({ error: 'Token em falta no header' });
        }
    
        const userId = await verifyToken(token);
        if (!userId) {
            return reply.status(401).send({ error: 'Token inv치lido' });
        }
        
        reply.send({ message: `Utilizador autenticado: ${userId}` });
    });
}

import { FastifyInstance } from 'fastify';
import { sendFriendRequest, acceptFriendRequest, getFriends, removeFriend, getUserByUsername, getPendingRequests, rejectFriendRequest } from '../services/friendsService.js';
import { verifyToken } from '../services/authService.js';


interface FriendRequestBody {
    friendUsername: string; // username of the friend to add
}


interface AcceptRequestBody {
    friendId: number;
}


export async function friendsRoutes(fastify: FastifyInstance) {


    // Send friend request by username
    fastify.post('/api/friends/request', async (req, reply) => {
        const authHeader = req.headers.authorization;
        if (!authHeader) {
            return reply.status(401).send({ error: 'Header de autoriza칞칚o em falta' });
        }


        const token = authHeader.split(' ')[1];
        if (!token) {
            return reply.status(401).send({ error: 'Token em falta' });
        }


        try {
            const userId = await verifyToken(token);
            if (!userId) {
                return reply.status(401).send({ error: 'Token inv치lido' });
            }


            const { friendUsername } = req.body as FriendRequestBody;
            
            if (!friendUsername) {
                return reply.status(400).send({ error: 'Username do amigo 칠 obrigat칩rio' });
            }


            // Check if friend exists
            const friend = await getUserByUsername(friendUsername);
            if (!friend) {
                return reply.status(404).send({ error: 'Utilizador n칚o encontrado' });
            }


            if (friend.id === userId) {
                return reply.status(400).send({ error: 'N칚o podes adicionar-te a ti pr칩prio' });
            }


            await sendFriendRequest(userId, friend.id);
            reply.status(201).send({ 
                success: true, 
                message: `Pedido de amizade enviado para ${friendUsername}` 
            });
        } 
        catch (err: any) {
            console.error('Erro ao enviar pedido:', err);
            if (err.message.includes('already exists')) {
                reply.status(409).send({ error: 'Pedido j치 existe ou j치 s칚o amigos' });
            } else {
                reply.status(500).send({ error: 'Erro interno do servidor' });
            }
        }
    });


    // Accept friend request
    fastify.post('/api/friends/accept', async (req, reply) => {
        const authHeader = req.headers.authorization;
        if (!authHeader) {
            return reply.status(401).send({ error: 'Header de autoriza칞칚o em falta' });
        }


        const token = authHeader.split(' ')[1];
        if (!token) {
            return reply.status(401).send({ error: 'Token em falta' });
        }


        try {
            const userId = await verifyToken(token);
            if (!userId) {
                return reply.status(401).send({ error: 'Token inv치lido' });
            }


            const { friendId } = req.body as AcceptRequestBody;
            
            if (!friendId || typeof friendId !== 'number') {
                return reply.status(400).send({ error: 'ID do amigo 칠 obrigat칩rio e deve ser n칰mero' });
            }


            await acceptFriendRequest(userId, friendId);
            reply.send({ 
                success: true, 
                message: 'Pedido de amizade aceite' 
            });
        } 
        catch (err: any) {
            console.error('Erro ao aceitar pedido:', err);
            if (err.message.includes('No pending')) {
                reply.status(404).send({ error: 'Pedido pendente n칚o encontrado' });
            } else {
                reply.status(500).send({ error: 'Erro interno do servidor' });
            }
        }
    });


    // List friends
    fastify.get('/api/friends', async (req, reply) => {
        const authHeader = req.headers.authorization;
        if (!authHeader) {
            return reply.status(401).send({ error: 'Header de autoriza칞칚o em falta' });
        }


        const token = authHeader.split(' ')[1];
        if (!token) {
            return reply.status(401).send({ error: 'Token em falta' });
        }


        try {
            const userId = await verifyToken(token);
            if (!userId) {
                return reply.status(401).send({ error: 'Token inv치lido' });
            }


            const friends = await getFriends(userId);
            reply.send({ friends });
        } 
        catch (err: any) {
            console.error('Erro ao buscar amigos:', err);
            reply.status(500).send({ error: 'Erro interno do servidor' });
        }
    });


    
    // Get pending friend requests
    fastify.get('/api/friends/pending', async (req, reply) => {
        const authHeader = req.headers.authorization;
        if (!authHeader) {
            return reply.status(401).send({ error: 'Header de autoriza칞칚o em falta' });
        }


        const token = authHeader.split(' ')[1];
        if (!token) {
            return reply.status(401).send({ error: 'Token em falta' });
        }


        try {
            const userId = await verifyToken(token);
            if (!userId) {
                return reply.status(401).send({ error: 'Token inv치lido' });
            }


            const pendingRequests = await getPendingRequests(userId);
            reply.send({ pending: pendingRequests });
        } 
        catch (err: any) {
            console.error('Erro ao buscar pedidos pendentes:', err);
            reply.status(500).send({ error: 'Erro interno do servidor' });
        }
    });


    // Reject friend request
    fastify.post('/api/friends/reject', async (req, reply) => {
        const authHeader = req.headers.authorization;
        if (!authHeader) {
            return reply.status(401).send({ error: 'Header de autoriza칞칚o em falta' });
        }


        const token = authHeader.split(' ')[1];
        if (!token) {
            return reply.status(401).send({ error: 'Token em falta' });
        }


        try {
            const userId = await verifyToken(token);
            if (!userId) {
                return reply.status(401).send({ error: 'Token inv치lido' });
            }


            const { friendId } = req.body as { friendId: number };
            
            if (!friendId || typeof friendId !== 'number') {
                return reply.status(400).send({ error: 'ID do amigo 칠 obrigat칩rio e deve ser n칰mero' });
            }


            await rejectFriendRequest(userId, friendId);
            reply.send({ 
                success: true, 
                message: 'Pedido de amizade rejeitado' 
            });
        } 
        catch (err: any) {
            console.error('Erro ao rejeitar pedido:', err);
            if (err.message.includes('No pending')) {
                reply.status(404).send({ error: 'Pedido pendente n칚o encontrado' });
            } else {
                reply.status(500).send({ error: 'Erro interno do servidor' });
            }
        }
    });


    // Remove friend
    fastify.delete('/api/friends/:friendId', async (req, reply) => {
        const authHeader = req.headers.authorization;
        if (!authHeader) {
            return reply.status(401).send({ error: 'Header de autoriza칞칚o em falta' });
        }
        
        const token = authHeader.split(' ')[1];
        if (!token) {
            return reply.status(401).send({ error: 'Token em falta' });
        }


        try {
            const userId = await verifyToken(token);
            if (!userId) {
                return reply.status(401).send({ error: 'Token inv치lido' });
            }


            const { friendId } = req.params as { friendId: string };
            const friendIdNum = parseInt(friendId);
            
            if (isNaN(friendIdNum)) {
                return reply.status(400).send({ error: 'ID do amigo inv치lido' });
            }


            await removeFriend(userId, friendIdNum);
            reply.send({ 
                success: true, 
                message: 'Amigo removido com sucesso' 
            });
        } 
        catch (err: any) {
            console.error('Erro ao remover amigo:', err);
            if (err.message.includes('No friendship found')) {
                reply.status(404).send({ error: 'Amizade n칚o encontrada' });
            } else {
                reply.status(500).send({ error: 'Erro interno do servidor' });
            }
        }
    });
}

//routes/gameRoutes.ts
import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { createGame, endGame, getPlayersFromGame } from '../services/gameService.js';
import { updateUserStatsAfterGame, getUserStatsById } from '../services/statsService.js';
import { updateTeamMember } from '../services/teamService.js';
import { getUserById } from '../services/usersService.js';
import { createMatchHistoryRecord } from '../services/matchHistoryService.js';


export async function gameRoutes(fastify: FastifyInstance) {
    fastify.post('/games', async (req: FastifyRequest, reply: FastifyReply) => {
        const { player1_id, player2_id, max_games, time_started } = req.body as {
        player1_id: number;
        player2_id: number;
        max_games: number;
        time_started: string;
        };


        try {
            const gameId = await createGame(player1_id, player2_id, max_games, time_started);
            reply.status(201).send({ message: 'Game created', game_id: gameId });
        } 
        catch (err) {
            console.error('Game creation error:', err);
            reply.status(500).send({ error: 'Failed to create game' });
        }
    });


    fastify.put('/games/:gameId/end', async (req: FastifyRequest, reply: FastifyReply) => {
        const { gameId } = req.params as { gameId: string };
        const { score_player1, score_player2 } = req.body as {
            score_player1: number;
            score_player2: number;
        };


        try {
            await endGame(gameId, score_player1, score_player2);


            const gameIdNum = Number(gameId);
            const { player1Id, player2Id } = await getPlayersFromGame(gameIdNum);
            await updateUserStatsAfterGame(gameIdNum, player1Id, player2Id, score_player1, score_player2);


            await syncUserStatsToTeam(player1Id);
            await syncUserStatsToTeam(player2Id);


            await createMatchHistoryRecord(gameIdNum, player1Id, player2Id, score_player1, score_player2, 0);
            await createMatchHistoryRecord(gameIdNum, player2Id, player1Id, score_player2, score_player1, 0);


            reply.status(200).send({ message: 'Game ended successfully' });
        } 
        catch (err) {
            console.error('Game ending error:', err);
            reply.status(500).send({ error: 'Failed to end game' });
        }
    });
}


const validTeams = {
    'HACKTIVISTS': 'hacktivists',
    'BUG BUSTERS': 'bug_busters',
    'LOGIC LEAGUE': 'logic_league',
    'CODE ALLIANCE': 'code_alliance'
};


export async function syncUserStatsToTeam(id: number): Promise<void> {
    const user = await getUserById(id);
    if (!user) 
        throw new Error(`User ${id} not found`);


    const teamTable = validTeams[user.team.toUpperCase() as keyof typeof validTeams];


    if (!teamTable) 
        throw new Error(`Invalid team name: ${user.team}`);


    const stats = await getUserStatsById(user.id);
    const winRate = stats.matches_played > 0 ? (stats.matches_won / stats.matches_played) * 100 : 0;
    
    console.log(
  'teamTable:', teamTable,
  '| user.id:', user.id,
  '| user.username:', user.username,
  '| stats.matches_won:', stats.matches_won,
  '| stats.tournaments_won:', stats.tournaments_won,
  '| stats.matches_lost:', stats.matches_lost,
  '| winRate:', winRate,);


    await updateTeamMember(teamTable, user.id, user.username, stats.matches_won,
    stats.tournaments_won, stats.matches_lost, winRate
    );
}

import { FastifyInstance } from "fastify";
import { getMatchHistory } from "../services/matchHistoryService.js";
import { verifyToken } from "../services/authService.js";


export async function matchHistoryRoutes(fastify: FastifyInstance) {
    fastify.get('/api/match-history', async (req, reply) => {
        const authHeader = req.headers.authorization;
        if (!authHeader)
            return reply.status(401).send({ error: 'Authorization header missing' });


        const token = authHeader.split(' ')[1];
        const userId = await verifyToken(token);
        if (!userId)
            return reply.status(401).send({ error: 'Invalid token' });


        try {
            const history = await getMatchHistory(userId);
            reply.send(history);
        } 
        catch (err) {
            reply.status(500).send({ error: 'Failed to fetch match history' });
        }
    });
}

//routes/statsRoutes.ts
import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { getAllUserStats, getUserStatsById } from '../services/statsService.js'; 


export async function statsRoutes(fastify: FastifyInstance) {
    fastify.get('/stats', async (_req: FastifyRequest, reply: FastifyReply) => {
        try {
            const stats = await getAllUserStats();
            reply.send(stats);
        } 
        catch (err) {
            console.error('Error fetching all user stats:', err);
            reply.status(500).send({ error: 'Failed to fetch user stats' });
        }
    });


    fastify.get('/stats/:userId', async (req: FastifyRequest, reply: FastifyReply) => {
        const { userId } = req.params as { userId: string };


        const userIdNum = Number(userId);
        if (isNaN(userIdNum)) {
            reply.status(400).send({ error: 'Invalid user ID' });
            return;
        }


        try {
            const stats = await getUserStatsById(userIdNum);
            reply.send(stats);
        } 
        catch (err) {
            console.error(`Error fetching stats for user ${userIdNum}:`, err);
            reply.status(404).send({ error: `Stats not found for user ${userIdNum}` });
        }
    });
}

//routes/teamRoutes.ts
import { FastifyInstance } from 'fastify';
import * as TeamService from '../services/teamService.js';


const validTeams = ['hacktivists', 'logic_league', 'bug_busters', 'code_alliance'];


export async function registerTeamRoutes(fastify: FastifyInstance) {


    fastify.get('/api/teams/:team', async (req, reply) => {
        const { team } = req.params as { team: string };


        if (!validTeams.includes(team))
            return reply.status(400).send({ error: 'Invalid team name' });


        try {
            const members = await TeamService.getAllTeamMembers(team);
            reply.send(members);
        } 
        catch (err) {
            reply.status(500).send({ error: 'Failed to fetch members' });
        }
    });


    fastify.post('/api/teams/:team', async (req, reply) => {
        const { team } = req.params as { team: string };
        const { members } = req.body as { members?: string };


        if (!validTeams.includes(team))
            return reply.status(400).send({ error: 'Invalid team name' });


        if (!members)
            return reply.status(400).send({ error: 'Members field is required' });


        try {
            await TeamService.createTeamMember(team, members);
            reply.status(201).send({ message: `Member added to ${team}` });
        } 
        catch (err) {
            reply.status(500).send({ error: 'Failed to add member' });
        }
    });


    fastify.put('/api/teams/:team/:id', async (req, reply) => {
        const { team, id } = req.params as { team: string; id: string };
        const { members, victories, tournaments_won, defeats, win_rate } = req.body as {
        members: string;
        victories: number;
        tournaments_won: number;
        defeats: number;
        win_rate: number;
        };


        if (!validTeams.includes(team))
            return reply.status(400).send({ error: 'Invalid team name' });


        if (!members)
            return reply.status(400).send({ error: 'Members field is required' });


        try {
            await TeamService.updateTeamMember(team, +id, members, victories, tournaments_won, defeats, win_rate);
            reply.send({ message: `${team} member updated` });
        } 
        catch (err) {
            reply.status(500).send({ error: 'Failed to update member' });
        }
    });


    fastify.delete('/api/teams/:team/:id', async (req, reply) => {
        const { team, id } = req.params as { team: string; id: string };


        if (!validTeams.includes(team))
            return reply.status(400).send({ error: 'Invalid team name' });


        try{
            await TeamService.deleteTeamMember(team, +id);
            reply.send({ message: `${team} member ${id} deleted` });
        } 
        catch (err) {
            reply.status(500).send({ error: 'Failed to delete member' });
        }
    });
}

//routes/tournamentRoutes.ts
import { FastifyInstance } from 'fastify';
import {createTournament, getAllTournaments, getTournamentById,
updateTournament, deleteTournament} from '../services/tournamentsService.js';


export async function tournamentRoutes(fastify: FastifyInstance) {
    fastify.post('/tournaments', async (request, reply) => {
        const { name, team_winner, team_victories, size } = request.body as {
        name: string;
        team_winner: string;
        team_victories: number;
        size: number;
        };


        try {
            await createTournament(name, team_winner, team_victories, size);
            reply.status(201).send({ message: 'Tournament created' });
        } 
        catch (error) {
            reply.status(500).send({ error: 'Failed to create tournament' });
        }
    });


    fastify.get('/tournaments', async (_request, reply) => {
        const tournaments = await getAllTournaments();
        reply.send(tournaments);
    });


    fastify.get('/tournaments/:id', async (request, reply) => {
        const { id } = request.params as { id: string };
        const tournament = await getTournamentById(Number(id));


        if (!tournament)
        return reply.status(404).send({ error: 'Tournament not found' });


        reply.send(tournament);
    });


    fastify.put('/tournaments/:id', async (request, reply) => {
        const { id } = request.params as { id: string };
        const { name, team_winner, team_victories, size } = request.body as {
        name: string;
        team_winner: string;
        team_victories: number;
        size: number;
        };


        try {
            await updateTournament(Number(id), name, team_winner, team_victories, size);
            reply.send({ message: 'Tournament updated' });
        } 
        catch (err) {
            reply.status(500).send({ error: 'Failed to update tournament' });
        }
    });


    fastify.delete('/tournaments/:id', async (request, reply) => {
        const { id } = request.params as { id: string };
        try {
            await deleteTournament(Number(id));
            reply.send({ message: 'Tournament deleted' });
        } 
        catch (err) {
            reply.status(500).send({ error: 'Failed to delete tournament' });
        }
    });
}

//routes/user.ts 
import { FastifyInstance } from 'fastify';
import { createUser, getAllUsers, deleteUser } from '../services/services.js';


export async function userRoutes(fastify: FastifyInstance) {
    fastify.post('/users', async (request, reply) => {
        const { name, username, team, password } = request.body as {
        name: string;
        username: string;
        team: string;
        password: string;
        };


        if (!name || !username || !team || !password)
        return reply.status(400).send({ error: 'Missing fields' });


        try {
            await createUser(name, username, team, password);
            return reply.status(201).send({ message: 'User created' });
        } 
        catch (err) {
            console.error('Error:', err);
            return reply.status(500).send({ error: 'Internal server error' });
        }
    });


    fastify.get('/users', async (_request, reply) => {
        const users = await getAllUsers();
        return reply.send(users);
    });


    fastify.delete('/users/:id', async (request, reply) => {
        const { id } = request.params as { id: string };


        try {
            await deleteUser(Number(id));
            return reply.send({ message: `User ${id} deleted` });
        } 
        catch (err) {
            console.error('Delete error:', err);
            return reply.status(500).send({ error: 'Failed to delete user' });
        }
    });
}

//routes/userProfileRoutes.ts
import { FastifyInstance } from 'fastify';
import { 
    getUserProfile, 
    updateUserProfile, 
    updateOnlineStatus, 
    getUserWithStats, 
    changeUserPassword
} from '../services/userProfileService.js';
import { verifyToken } from '../services/authService.js';
import db from '../db/database.js';


interface UpdateProfileRequest {
    username?: string;
    display_name?: string;
    email?: string;
    avatar_url?: string;
}


interface UpdateStatusRequest {
    online: boolean;
}


export async function userProfileRoutes(fastify: FastifyInstance) {
    
    // Obtain user profile 
    fastify.get('/api/profile', async (req, reply) => {
        const authHeader = req.headers.authorization;
        if (!authHeader) {
            return reply.status(401).send({ error: 'Header de autoriza칞칚o em falta' });
        }


        const token = authHeader.split(' ')[1];
        if (!token) {
            return reply.status(401).send({ error: 'Token em falta' });
        }


        try {
            const userId = await verifyToken(token);
            if (!userId) {
                return reply.status(401).send({ error: 'Token inv치lido' });
            }


            const userProfile = await getUserProfile(userId);
            if (!userProfile) {
                return reply.status(404).send({ error: 'Perfil n칚o encontrado' });
            }


            reply.send(userProfile);
        } 
        catch (err: any) {
            console.error('Erro ao buscar perfil:', err);
            reply.status(500).send({ error: 'Erro interno do servidor' });
        }
    });


    // Obtain profile with stats
    fastify.get('/api/profile/stats', async (req, reply) => {
        const authHeader = req.headers.authorization;
        if (!authHeader) {
            return reply.status(401).send({ error: 'Header de autoriza칞칚o em falta' });
        }


        const token = authHeader.split(' ')[1];
        if (!token) {
            return reply.status(401).send({ error: 'Token em falta' });
        }


        try {
            const userId = await verifyToken(token);
            if (!userId) {
                return reply.status(401).send({ error: 'Token inv치lido' });
            }


            const userWithStats = await getUserWithStats(userId);
            if (!userWithStats) {
                return reply.status(404).send({ error: 'Utilizador n칚o encontrado' });
            }


            reply.send(userWithStats);
        } 
        catch (err: any) {
            console.error('Erro ao buscar perfil com stats:', err);
            reply.status(500).send({ error: 'Erro interno do servidor' });
        }
    });


    // Update user profile
    fastify.put('/api/profile', async (req, reply) => {
        const authHeader = req.headers.authorization;
        if (!authHeader) {
            return reply.status(401).send({ error: 'Header de autoriza칞칚o em falta' });
        }


        const token = authHeader.split(' ')[1];
        if (!token) {
            return reply.status(401).send({ error: 'Token em falta' });
        }


        try {
            const userId = await verifyToken(token);
            if (!userId) {
                return reply.status(401).send({ error: 'Token inv치lido' });
            }


            const updates = req.body as UpdateProfileRequest;
            
            // Basic validation
            if (updates.email && !updates.email.includes('@')) {
                return reply.status(400).send({ error: 'Email inv치lido' });
            }


            if (updates.username && updates.username.length < 3) {
                return reply.status(400).send({ error: 'Username deve ter pelo menos 3 caracteres' });
            }


            await updateUserProfile(userId, updates);
            reply.send({ success: true, message: 'Perfil atualizado com sucesso' });
        } 
        catch (err: any) {
            console.error('Erro ao atualizar perfil:', err);
            if (err.message.includes('UNIQUE constraint failed')) {
                reply.status(409).send({ error: 'Username ou email j치 existe' });
            } else {
                reply.status(500).send({ error: err.message || 'Erro interno do servidor' });
            }
        }
    });


    // Update online status
    fastify.post('/api/profile/status', async (req, reply) => {
        const authHeader = req.headers.authorization;
        if (!authHeader) {
            return reply.status(401).send({ error: 'Header de autoriza칞칚o em falta' });
        }


        const token = authHeader.split(' ')[1];
        if (!token) {
            return reply.status(401).send({ error: 'Token em falta' });
        }


        try {
            const userId = await verifyToken(token);
            if (!userId) {
                return reply.status(401).send({ error: 'Token inv치lido' });
            }


            const { online } = req.body as UpdateStatusRequest;
            
            if (typeof online !== 'boolean') {
                return reply.status(400).send({ error: 'Campo "online" deve ser boolean' });
            }


            await updateOnlineStatus(userId, online);
            reply.send({ 
                success: true, 
                message: `Status alterado para ${online ? 'online' : 'offline'}` 
            });
        } 
        catch (err: any) {
            console.error('Erro ao atualizar status:', err);
            reply.status(500).send({ error: err.message || 'Erro interno do servidor' });
        }
    });


    // Change password
    fastify.post('/api/profile/change-password', async (req, reply) => {
        const authHeader = req.headers.authorization;
        if (!authHeader) {
            return reply.status(401).send({ error: 'Header de autoriza칞칚o em falta' });
        }


        const token = authHeader.split(' ')[1];
        if (!token) {
            return reply.status(401).send({ error: 'Token em falta' });
        }


        try {
            const userId = await verifyToken(token);
            if (!userId) {
                return reply.status(401).send({ error: 'Token inv치lido' });
            }


            const { currentPassword, newPassword } = req.body as { 
                currentPassword: string; 
                newPassword: string;
            };
            
            if (!currentPassword || !newPassword) {
                return reply.status(400).send({ error: 'Password atual e nova s칚o obrigat칩rias' });
            }


            if (newPassword.length < 6) {
                return reply.status(400).send({ error: 'Nova password deve ter pelo menos 6 caracteres' });
            }


            await changeUserPassword(userId, currentPassword, newPassword);
            reply.send({ 
                success: true, 
                message: 'Password alterada com sucesso' 
            });
        } 
        catch (err: any) {
            console.error('Erro ao alterar password:', err);
            if (err.message.includes('Password atual incorreta')) {
                reply.status(400).send({ error: 'Password atual incorreta' });
            } else {
                reply.status(500).send({ error: 'Erro interno do servidor' });
            }
        }
    });


    // Update last seen
    fastify.post('/api/profile/update-last-seen', async (req, reply) => {
        const authHeader = req.headers.authorization;
        if (!authHeader) {
            return reply.status(401).send({ error: 'Header de autoriza칞칚o em falta' });
        }


        const token = authHeader.split(' ')[1];
        if (!token) {
            return reply.status(401).send({ error: 'Token em falta' });
        }


        try {
            const userId = await verifyToken(token);
            if (!userId) {
                return reply.status(401).send({ error: 'Token inv치lido' });
            }


            db.run(
                `UPDATE users SET last_seen = CURRENT_TIMESTAMP WHERE id = ?`,
                [userId],
                function (err) {
                    if (err) {
                        console.error('Erro ao atualizar last_seen:', err);
                        return reply.status(500).send({ error: 'Erro interno' });
                    }
                    reply.send({ success: true });
                }
            );
        } catch (err: any) {
            console.error('Erro:', err);
            reply.status(500).send({ error: 'Erro interno do servidor' });
        }
    });
}

//services/authService.ts
import db from '../db/database.js';
import * as bcrypt from 'bcrypt';
import { v4 as uuidv4 } from 'uuid';
import { User } from '../types/user.js';
import { Session } from '../types/session.js';


export async function registerUser({ 
  username, 
  password, 
  name, 
  team, 
  display_name, 
  email 
}: {
  username: string;
  password: string;
  name: string;
  team: string;
  display_name?: string;
  email?: string;
}): Promise<{ id: number }> {
  const hashedPassword = await bcrypt.hash(password, 10);
  
  return new Promise((resolve, reject) => {
      // Query to insert new user
      db.run(
          `INSERT INTO users (username, password, name, team, display_name, email) 
           VALUES (?, ?, ?, ?, ?, ?)`,
          [username, hashedPassword, name, team, display_name || null, email || null],
          function (err) {
              if (err) {
                  console.error('Erro ao inserir utilizador:', err);
                  reject(err);
              } else {
                  console.log('Novo utilizador criado com sucesso');
                  resolve({ id: this.lastID });
              }
          }
      );
  });
}


export async function loginUser(username: string, password: string): Promise<{ token: string } | null> {
  return new Promise((resolve, reject) => {
      db.get(`SELECT * FROM users WHERE username = ?`, [username], async (err, userRaw) => {
          if (err) {
              console.error('Erro na consulta de utilizador:', err);
              return reject(err);
          }
          
          if (!userRaw) {
              console.log('Utilizador nao encontrado');
              return resolve(null);
          }


          const user = userRaw as User;
          
          try {
              const match = await bcrypt.compare(password, user.password);
              if (!match) {
                  return resolve(null);
              }


              // Token generation
              const token = uuidv4();
              const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(); // 24 hours


              // Use serialize to ensure sequential execution
              db.serialize(() => {                    
                // Insert session into 
                db.run(
                    `INSERT INTO sessions (user_id, token, expires_at) VALUES (?, ?, ?)`,
                    [user.id, token, expiresAt],
                    function (err) {
                        if (err) {
                            console.error('Erro ao criar sess칚o:', err);
                            reject(err);
                        } else {
                            resolve({ token });
                        }
                        // Update user status to online
                        db.run(
                            `UPDATE users SET online_status = 1, last_seen = CURRENT_TIMESTAMP WHERE id = ?`,
                            [user.id],
                            function (err) {
                                if (err) {
                                    console.error('Erro ao atualizar status online:', err);
                                    reject(err);
                                } else {
                                    console.log(`User ${user.id} set to online`);
                                    resolve({ token });
                                }
                            }
                        );
                    }
                );
             });
          } catch (bcryptErr) {
              console.error('Erro na compara칞칚o de password:', bcryptErr);
              reject(bcryptErr);
          }
      });
  });
}


export async function verifyToken(token: string): Promise<number | null> {
  return new Promise((resolve, reject) => {
      db.get(
          `SELECT * FROM sessions WHERE token = ? AND expires_at > datetime('now')`, 
          [token], 
          (err, sessionRaw) => {
              if (err) {
                  console.error('Erro na verifica칞칚o do token:', err);
                  return reject(err);
              }


              if (!sessionRaw) {
                  return resolve(null);
              }


              const session = sessionRaw as Session;
              resolve(session.user_id);
          }
      );
  });
}


// Function to clean up expired sessions
export async function cleanExpiredSessions(): Promise<void> {
  return new Promise((resolve, reject) => {
      db.run(
          `DELETE FROM sessions WHERE expires_at < datetime('now')`,
          [],
          function (err) {
              if (err) {
                  console.error('Erro ao limpar sess칫es expiradas:', err);
                  reject(err);
              } else {
                  console.log(`${this.changes} sess칫es expiradas removidas`);
                  resolve();
              }
          }
      );
  });
}

//services/friendsService.ts
import db from '../db/database.js';
import { Friendship } from '../types/friendship.js';
import { User } from '../types/user.js';


// Function to get user by username
export async function getUserByUsername(username: string): Promise<User | null> {
    return new Promise((resolve, reject) => {
        db.get(`SELECT * FROM users WHERE username = ?`, [username], (err, row) => {
            if (err) {
                console.error('Erro ao buscar utilizador:', err);
                reject(err);
            } else {
                resolve(row ? (row as User) : null);
            }
        });
    });
}


// Send friend request
export async function sendFriendRequest(userId: number, friendId: number): Promise<void> {
    return new Promise((resolve, reject) => {
        //Check if friendship or pending request already exists
        db.get(
            `SELECT * FROM friendships 
             WHERE (user_id = ? AND friend_id = ?) OR (user_id = ? AND friend_id = ?)`, 
            [userId, friendId, friendId, userId], 
            (err, row) => {
                if (err) {
                    console.error('Erro ao verificar amizade:', err);
                    return reject(err);
                }
                
                if (row) {
                    return reject(new Error('Pedido j치 existe ou utilizadores j치 s칚o amigos'));
                }


                // Insert new friend request
                db.run(
                    `INSERT INTO friendships (user_id, friend_id, status) VALUES (?, ?, 'pending')`,
                    [userId, friendId],
                    function (err) {
                        if (err) {
                            console.error('Erro ao inserir pedido:', err);
                            reject(err);
                        } else {
                            resolve();
                        }
                    }
                );
            }
        );
    });
}


// Accept friend request
export async function acceptFriendRequest(userId: number, friendId: number): Promise<void> {
    return new Promise((resolve, reject) => {
        db.serialize(() => {
            // Atualizar pedido para aceite
            db.run(
                `UPDATE friendships SET status = 'accepted' 
                 WHERE user_id = ? AND friend_id = ? AND status = 'pending'`,
                [friendId, userId],
                function (err) {
                    if (err) {
                        console.error('Erro ao aceitar pedido:', err);
                        return reject(err);
                    }
                    
                    if (this.changes === 0) {
                        return reject(new Error('Pedido pendente n칚o encontrado'));
                    }


                    // Criar rela칞칚o inversa
                    db.run(
                        `INSERT INTO friendships (user_id, friend_id, status) VALUES (?, ?, 'accepted')`,
                        [userId, friendId],
                        function (err) {
                            if (err) {
                                console.error('Erro ao criar rela칞칚o inversa:', err);
                                reject(err);
                            } else {
                                resolve();
                            }
                        }
                    );
                }
            );
        });
    });
}


// Obtain friends list
export async function getFriends(userId: number): Promise<any[]> {
    return new Promise((resolve, reject) => {
        const query = `
            SELECT 
                f.*,
                u.username,
                u.name,
                u.display_name,
                u.avatar_url,
                u.online_status,
                u.last_seen,
                u.team
            FROM friendships f
            JOIN users u ON f.friend_id = u.id
            WHERE f.user_id = ? AND f.status = 'accepted'
            ORDER BY u.online_status DESC, u.last_seen DESC
        `;
        
        db.all(query, [userId], (err, rows) => {
            if (err) {
                console.error('Erro ao buscar amigos:', err);
                reject(err);
            } else {
                resolve(rows || []);
            }
        });
    });
}


// Obtain pending friend requests
export async function getPendingRequests(userId: number): Promise<any[]> {
    return new Promise((resolve, reject) => {
        const query = `
            SELECT 
                f.*,
                u.username,
                u.name,
                u.display_name,
                u.avatar_url,
                u.team
            FROM friendships f
            JOIN users u ON f.user_id = u.id
            WHERE f.friend_id = ? AND f.status = 'pending'
            ORDER BY f.created_at DESC
        `;
        
        db.all(query, [userId], (err, rows) => {
            if (err) {
                console.error('Erro ao buscar pedidos pendentes:', err);
                reject(err);
            } else {
                resolve(rows || []);
            }
        });
    });
}


// Remove friend(remove friendship in both directions)
export async function removeFriend(userId: number, friendId: number): Promise<void> {
    return new Promise((resolve, reject) => {
        db.run(
            `DELETE FROM friendships 
             WHERE (user_id = ? AND friend_id = ?) OR (user_id = ? AND friend_id = ?)`,
            [userId, friendId, friendId, userId],
            function (err) {
                if (err) {
                    console.error('Erro ao remover amigo:', err);
                    reject(err);
                } else if (this.changes === 0) {
                    reject(new Error('Amizade n칚o encontrada'));
                } else {
                    resolve();
                }
            }
        );
    });
}


// Reject friend request
export async function rejectFriendRequest(userId: number, friendId: number): Promise<void> {
    return new Promise((resolve, reject) => {
        db.run(
            `DELETE FROM friendships 
             WHERE user_id = ? AND friend_id = ? AND status = 'pending'`,
            [friendId, userId],
            function (err) {
                if (err) {
                    console.error('Erro ao rejeitar pedido:', err);
                    reject(err);
                } else if (this.changes === 0) {
                    reject(new Error('Pedido pendente n칚o encontrado'));
                } else {
                    resolve();
                }
            }
        );
    });
}

//services/gameService.ts
import db from '../db/database.js';
import type { GameRecord, GamePlayers } from '../types/game.js';



export function createGame(player1Id: number, player2Id: number, maxGames: number,
timeStarted: string): Promise<number> {
    return new Promise((resolve, reject) => {
        db.run(
        `INSERT INTO games (player1_id, player2_id, max_games, score_player1, score_player2, time_started)
        VALUES (?, ?, ?, 0, 0, ?)`,
        [player1Id, player2Id, maxGames, timeStarted],
        function (err) {
            if (err) 
                reject(err);
            else 
                resolve(this.lastID);
        }
        );
    });
}


export function endGame(gameId: string, score1: number, score2: number): Promise<void> {
    return new Promise((resolve, reject) => {
        db.run(
            `UPDATE games
             SET score_player1 = ?, score_player2 = ?
             WHERE game_id = ?`,
            [score1, score2, gameId],
            function (err) {
                if (err)
                    reject(err);
                else
                    resolve();
            }
        );
    });
}


export function getPlayersFromGame(gameId: number): Promise<GamePlayers> {
    return new Promise((resolve, reject) => {
        db.get(
            `SELECT player1_id, player2_id FROM games WHERE game_id = ?`,
            [gameId],
            (err, row: { player1_id: number; player2_id: number } | undefined) => {
                if (err)
                    reject(err);
                else if (!row)
                    reject(new Error(`Game with ID ${gameId} not found.`));
                else {
                    resolve({
                        player1Id: row.player1_id,
                        player2Id: row.player2_id,
                    });
                }
            }
        );
    });
}

//services/matchHistoryService.ts
import db from '../db/database.js';
import { MatchHistoryRecord } from '../types/matchHistory.js';


export async function createMatchHistoryRecord(
    gameId: number,
    userId: number,
    opponentId: number,
    userScore: number,
    opponentScore: number,
    duration: number,
){
    const result = userScore > opponentScore ? 'win' : 'loss';
    return new Promise<void>((resolve, reject) => {
        db.run(
            `INSERT INTO match_history (game_id, user_id, opponent_id, user_score, opponent_score, result, duration, date_played)
             VALUES (?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
            [gameId, userId, opponentId, userScore, opponentScore, result, duration],
            function(err) {
                if (err) reject(err);
                else resolve();
            }
        );
    });
}


export async function getMatchHistory(userId: number): Promise<MatchHistoryRecord[]> {
    return new Promise((resolve, reject) => {
        db.all(
            `SELECT * FROM match_history WHERE user_id = ? ORDER BY date_played DESC LIMIT 20`,
            [userId],
            (err, rows) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(rows as MatchHistoryRecord[]);
                }
            }
        );
    });
}

//services/services.ts
export * from './usersService.js';
export * from './userStatsService.js';
export * from './tournamentsService.js';
export * from './teamService.js';

//services/statsService.ts
import db from '../db/database.js';


import {UserStats} from '../types/userStats.js';


export function createUserStats(userId: number): Promise<void> {
    return new Promise((resolve, reject) => {
        const insertQuery = `INSERT OR IGNORE INTO user_stats (user_id) VALUES (?)`;
        db.run(insertQuery, [userId], (err) => {
            if (err) {
                console.error(`Failed to insert stats for user ${userId}:`, err.message);
                reject(err);
            } 
            else {
                console.log(`Stats initialized for user ${userId}.`);
                resolve();
            }
        });
    });
}


export function updateUserStatsAfterGame(
    gameId: number,
    player1Id: number,
    player2Id: number,
    score1: number,
    score2: number
): Promise<void> {
    return new Promise(async (resolve, reject) => {
        console.log(`Starting updateUserStatsAfterGame for game ${gameId}`);
        
        try {
            await ensureUserStatsExist(player1Id);
            await ensureUserStatsExist(player2Id);


            db.serialize(() => {
                let completed = 0;


                const updateStats = (
                    userId: number,
                    scored: number,
                    conceded: number,
                    won: boolean
                ) => {
                    console.log(`Updating stats for user ${userId}: scored=${scored}, conceded=${conceded}, won=${won}`);
                    const winInc = won ? 1 : 0;
                    const lossInc = won ? 0 : 1;


                    db.run(
                        `UPDATE user_stats
                        SET matches_played = matches_played + 1,
                            matches_won = matches_won + ?,
                            matches_lost = matches_lost + ?,
                            points_scored = points_scored + ?,
                            points_conceded = points_conceded + ?,
                            win_rate = CAST(matches_won + ? AS REAL) / CAST(matches_played + 1 AS REAL)
                        WHERE user_id = ?`,
                        [winInc, lossInc, scored, conceded, winInc, userId],
                        (err) => {
                            if (err) {
                                console.error(`Error updating stats for user ${userId}:`, err);
                                return reject(err);
                            }
                            console.log(`Successfully updated stats for user ${userId}`);
                            completed++;
                            if (completed === 2) {
                                console.log(`Finished updating stats for game ${gameId}`);
                                resolve();
                            }
                        }
                    );
                };


                updateStats(player1Id, score1, score2, score1 > score2);
                updateStats(player2Id, score2, score1, score2 > score1);
            });
        } 
        catch (err) {
            console.error(`Error updating stats for game ${gameId}:`, err);
            reject(err);
        }
    });
}


export function ensureUserStatsExist(userId: number): Promise<void> {
    return new Promise((resolve, reject) => {
        // Verify if stats exist
        db.get(`SELECT user_id FROM user_stats WHERE user_id = ?`, [userId], (err, row) => {
            if (err) return reject(err);
            
            if (!row) {
                // Create stats if they do not exist
                createUserStats(userId).then(resolve).catch(reject);
            } else {
                resolve();
            }
        });
    });
}


export function getAllUserStats(): Promise<UserStats[]> {
    return new Promise((resolve, reject) => {
        db.all(`SELECT * FROM user_stats`, (err, rows) => {
            if (err){
                console.error('Failed to fetch user stats:', err.message);
                reject(err);
            }
            else 
                resolve(rows as UserStats[]);
        });
    });
}


export function getUserStatsById(userId: number): Promise<UserStats> {
    return new Promise((resolve, reject) => {
        db.get(`SELECT * FROM user_stats WHERE user_id = ?`, [userId], (err, row) => {
            if (err) {
                console.error(`Failed to fetch stats for user ${userId}:`, err.message);
                reject(err);
            } 
            else if (!row)
                reject(new Error(`No stats found for user ${userId}`));
            else
                resolve(row as UserStats);
        });
    });
}

//services/teamService.ts
import db from '../db/database.js';
import { TeamStats } from '../types/team.js';


function runAsync(query: string, params: any[] = []): Promise<void> {
    return new Promise((resolve, reject) => {
        db.run(query, params, function (err) {
        if (err) 
            reject(err);
        else 
            resolve();
        });
    });
}


function getAsync<T = any>(query: string, params: any[] = []): Promise<T | undefined> {
    return new Promise((resolve, reject) => {
        db.get(query, params, (err, row) => {
        if (err) 
            reject(err);
        else 
            resolve(row as T);
        });
    });
}


function allAsync<T = any>(query: string, params: any[] = []): Promise<T[]> {
    return new Promise((resolve, reject) => {
        db.all(query, params, (err, rows) => {
        if (err) 
            reject(err);
        else 
            resolve(rows as T[]);
        });
    });
}


export function createTeamMember(table: string, members: string): Promise<void> {
    const query = `INSERT INTO ${table} (members) VALUES (?)`;
    return runAsync(query, [members]);
}


export function getAllTeamMembers(table: string): Promise<TeamStats[]> {
    const query = `SELECT * FROM ${table}`;
    return allAsync<TeamStats>(query);
}


export function getTeamMemberById(table: string, id: number): Promise<TeamStats | undefined> {
    const query = `SELECT * FROM ${table} WHERE id = ?`;
    return getAsync<TeamStats>(query, [id]);
}


export function updateTeamMember( table: string, id: number, members: string,
victories: number, tournaments_won: number, defeats: number, win_rate: number): Promise<void> {
    const query = `UPDATE ${table} SET members = ?, victories = ?, tournaments_won = ?, defeats = ?, win_rate = ? WHERE id = ?`;
    return runAsync(query, [members, victories, tournaments_won, defeats, win_rate, id]);
}


export function deleteTeamMember(table: string, id: number): Promise<void> {
    const query = `DELETE FROM ${table} WHERE id = ?`;
    return runAsync(query, [id]);
}

//services/tournamentsService.ts
import db from '../db/database.js';
import { Tournament } from '../types/tournament.js';


function runAsync(query: string, params: any[] = []): Promise<void> {
    return new Promise((resolve, reject) => {
        db.run(query, params, function (err) {
        if (err) 
            reject(err);
        else 
            resolve();
        });
    });
}


function getAsync<T = any>(query: string, params: any[] = []): Promise<T | undefined> {
    return new Promise((resolve, reject) => {
        db.get(query, params, (err, row) => {
        if (err) 
            reject(err);
        else 
            resolve(row as T);
        });
    });
}


function allAsync<T = any>(query: string, params: any[] = []): Promise<T[]> {
    return new Promise((resolve, reject) => {
        db.all(query, params, (err, rows) => {
        if (err)
            reject(err);
        else
            resolve(rows as T[]);
        });
    });
}


export function createTournament(name: string, team_winner: string,
team_victories: number, size: number): Promise<void> {
    const query = `INSERT INTO tournaments (name, team_winner, team_victories, size)
    VALUES (?, ?, ?, ?)`;
    return runAsync(query, [name, team_winner, team_victories, size]);
}


export function getAllTournaments(): Promise<Tournament[]> {
    const query = `SELECT * FROM tournaments`;
    return allAsync<Tournament>(query);
}


export function getTournamentById(id: number): Promise<Tournament | undefined> {
    const query = `SELECT * FROM tournaments WHERE id = ?`;
    return getAsync<Tournament>(query, [id]);
}


export function updateTournament(id: number, name: string, team_winner: string,
team_victories: number, size: number): Promise<void> {
    const query = `UPDATE tournaments SET name = ?, team_winner = ?, team_victories = ?, size = ?
    WHERE id = ?`;
    return runAsync(query, [name, team_winner, team_victories, size, id]);
}


export function deleteTournament(id: number): Promise<void> {
    const query = `DELETE FROM tournaments WHERE id = ?`;
    return runAsync(query, [id]);
}

//services/userProfileService.ts
import db from '../db/database.js';
import { User } from '../types/user.js';
import * as bcrypt from 'bcrypt';


// Function to get user profile by IDexport async function getUserProfile(userId: number)
export async function getUserProfile(userId: number)
: Promise<Omit<User, 'password'> | null> {
  return new Promise((resolve, reject) => {
    db.get(`SELECT id, username, name, team, display_name, email, avatar_url, online_status, last_seen, created_at FROM users WHERE id = ?`, [userId], (err, row) => {
      if (err) {
        console.error('仇 Erro ao buscar perfil:', err);
        reject(err);
      } else {
        console.log('九 Perfil encontrado:', row);
        resolve(row ? (row as Omit<User, 'password'>) : null);
      }
    });
  });
}


// Function to update user profile
export async function updateUserProfile(
    userId: number, 
    updates: Partial<Pick<User, 'username' | 'display_name' | 'email' | 'avatar_url'>>
): Promise<void> {
    // Filter out undefined or null fields
    const entries = Object.entries(updates).filter(([_, value]) => 
        value !== undefined && value !== null && value !== ''
    );
    
    if (entries.length === 0) {
        throw new Error('Nenhum campo para atualizar');
    }


    const setClause = entries.map(([key]) => `${key} = ?`).join(', ');
    const values = entries.map(([_, value]) => value);


    return new Promise((resolve, reject) => {
        db.run(
            `UPDATE users SET ${setClause} WHERE id = ?`,
            [...values, userId],
            function (err) {
                if (err) {
                    console.error('Erro ao atualizar perfil:', err);
                    reject(err);
                } else if (this.changes === 0) {
                    reject(new Error('Utilizador n칚o encontrado'));
                } else {
                    resolve();
                }
            }
        );
    });
}


// Function to update user's online status
export async function updateOnlineStatus(userId: number, isOnline: boolean): Promise<void> {
    return new Promise((resolve, reject) => {
        db.run(
            `UPDATE users SET online_status = ?, last_seen = CURRENT_TIMESTAMP WHERE id = ?`,
            [isOnline ? 1 : 0, userId],
            function (err) {
                if (err) {
                    console.error('Erro ao atualizar status online:', err);
                    reject(err);
                } else if (this.changes === 0) {
                    reject(new Error('Utilizador n칚o encontrado'));
                } else {
                    resolve();
                }
            }
        );
    });
}


// Function to get user with stats
export async function getUserWithStats(userId: number): Promise<any> {
    return new Promise((resolve, reject) => {
        const query = `
            SELECT 
                u.id, u.username, u.name, u.team, u.display_name, u.email, 
                u.avatar_url, u.online_status, u.last_seen, u.created_at,
                COALESCE(s.matches_played, 0) as matches_played,
                COALESCE(s.matches_won, 0) as matches_won,
                COALESCE(s.matches_lost, 0) as matches_lost,
                COALESCE(s.points_scored, 0) as points_scored,
                COALESCE(s.points_conceded, 0) as points_conceded,
                COALESCE(s.win_rate, 0) as win_rate,
                COALESCE(s.tournaments_played, 0) as tournaments_played,
                COALESCE(s.tournaments_won, 0) as tournaments_won
            FROM users u
            LEFT JOIN user_stats s ON u.id = s.user_id
            WHERE u.id = ?
        `;
        
        db.get(query, [userId], (err, row) => {
            if (err) {
                console.error('Erro ao buscar utilizador com stats:', err);
                reject(err);
            } else {
                resolve(row || null);
            }
        });
    });
}


// Function to change user password
export async function changeUserPassword(
    userId: number, 
    currentPassword: string, 
    newPassword: string
): Promise<void> {
    return new Promise((resolve, reject) => {
        // First get current user data
        db.get(`SELECT password FROM users WHERE id = ?`, [userId], async (err, row) => {
            if (err) {
                console.error('Erro ao buscar utilizador:', err);
                return reject(err);
            }
            
            if (!row) {
                return reject(new Error('Utilizador n칚o encontrado'));
            }


            const user = row as { password: string };
            
            try {
                // Verify current password
                const match = await bcrypt.compare(currentPassword, user.password);
                if (!match) {
                    return reject(new Error('Password atual incorreta'));
                }


                // Hash new password
                const hashedNewPassword = await bcrypt.hash(newPassword, 10);
                
                // Update password in database
                db.run(
                    `UPDATE users SET password = ? WHERE id = ?`,
                    [hashedNewPassword, userId],
                    function (err) {
                        if (err) {
                            console.error('Erro ao atualizar password:', err);
                            reject(err);
                        } else if (this.changes === 0) {
                            reject(new Error('Utilizador n칚o encontrado'));
                        } else {
                            resolve();
                        }
                    }
                );
            } catch (bcryptErr) {
                console.error('Erro na compara칞칚o de password:', bcryptErr);
                reject(bcryptErr);
            }
        });
    });
}

//services/usersService.ts


import db from '../db/database.js';
import bcrypt from 'bcrypt';
import { User } from '../types/user.js';
import { createTeamMember } from './teamService.js';
import { createUserStats } from './statsService.js';


function runAsync(query: string, params: any[] = []): Promise<void> {
    return new Promise((resolve, reject) => {
        db.run(query, params, function (err) {
        if (err) 
            reject(err);
        else 
            resolve();
        });
    });
}


function getAsync<T = any>(query: string, params: any[] = []): Promise<T | undefined> {
    return new Promise((resolve, reject) => {
        db.get(query, params, (err, row) => {
        if (err) 
            reject(err);
        else 
            resolve(row as T);
        });
    });
}


function allAsync<T = any>(query: string, params: any[] = []): Promise<T[]> {
    return new Promise((resolve, reject) => {
        db.all(query, params, (err, rows) => {
        if (err) 
            reject(err);
        else
            resolve(rows as T[]);
        });
    });
}


const validTeams = {
    'HACKTIVISTS': 'hacktivists',
    'BUG BUSTERS': 'bug_busters',
    'LOGIC LEAGUE': 'logic_league',
    'CODE ALLIANCE': 'code_alliance'
};


export async function createUser(name: string, username: string, team: string, password: string): Promise<void> {
    const teamKey = validTeams[team.toUpperCase() as keyof typeof validTeams];
    if (!teamKey)
        throw new Error('Invalid team name');


    const existingUser = await getUserByUsername(username);
    if (existingUser) 
        throw new Error('Username already exists');


    const hashedPassword = await bcrypt.hash(password, 10);
    const query = `INSERT INTO users (name, username, team, password) VALUES (?, ?, ?, ?)`;
    await runAsync(query, [name, username, team, hashedPassword]);


    await createTeamMember(teamKey, username);


    const newUser = await getUserByUsername(username);
    if (!newUser)
        throw new Error('Failed to retrieve newly created user');
    const userId = newUser.id;
    await createUserStats(userId);
}


export async function getAllUsers(): Promise<User[]> {
    const query = `SELECT * FROM users`;
    return await allAsync<User>(query);
}



export async function getUserById(userId: number): Promise<User | undefined> {
    const query = `SELECT * FROM users WHERE id = ?`;
    return await getAsync<User>(query, [userId]);
}


export async function getUserByUsername(username: string): Promise<User | undefined> {
    const query = `SELECT * FROM users WHERE username = ?`;
    return await getAsync<User>(query, [username]);
}


export async function updateUser(id: number, name: string, team: string): Promise<void> {
    const query = `UPDATE users SET name = ?, team = ? WHERE id = ?`;
    await runAsync(query, [name, team, id]);
}


export async function deleteUser(id: number): Promise<void> {
    const query = `DELETE FROM users WHERE id = ?`;
    await runAsync(query, [id]);
}

//services/userStatsService.ts


import db from '../db/database.js';
import { UserMatch } from '../types/userStats.js';


export function insertUserMatch(userId: string | number, match: UserMatch): void {
    const tableName = `stats_user_${userId}`;
    const query = `
        INSERT INTO ${tableName} (result, match_duration, goals_scored, goals_conceded, date_played)
        VALUES (?, ?, ?, ?, ?)
    `;
    const { result, match_duration, goals_scored, goals_conceded, date_played } = match;


    db.run(query, [result, match_duration, goals_scored, goals_conceded, date_played], (err) => {
        if (err)
            console.error(`Failed to insert match for user ${userId}:`, err.message);
        else
            console.log(`Match inserted for user ${userId}`);
    });
}


export function getUserMatches(userId: string | number,
callback: (err: Error | null, rows?: UserMatch[]) => void): void {
    const tableName = `stats_user_${userId}`;
    const query = `SELECT * FROM ${tableName} ORDER BY date_played DESC`;


    db.all(query, (err, rows) => {
        callback(err, rows as UserMatch[]);
    });
}


export function deleteUserMatch(userId: string | number, matchId: number,
callback: (err: Error | null) => void): void {
    const tableName = `stats_user_${userId}`;
    const query = `DELETE FROM ${tableName} WHERE match_id = ?`;


    db.run(query, [matchId], (err) => {
        callback(err);
    });
}

//types/fastify-static.d.ts
declare module '@fastify/static';
declare module '@fastify/cors';
declare module '@fastify/websocket';
declare module 'bcrypt';

export interface Friendship {
  id: number;
  user_id: number;
  friend_id: number;
  status: 'pending' | 'accepted' | 'blocked';
  created_at: string;
  friend_name?: string;
  friend_username?: string;
  friend_display_name?: string;
  friend_avatar?: string;
  friend_online?: boolean;
}

//types/game.ts
export type GameRecord = {
    game_id: number;
    player1_id: number;
    player2_id: number;
    max_games: number;
    score_player1: number;
    score_player2: number;
    time_started: string;
    time_ended?: string | null;
    winner_id?: number | null;
    match_duration: number;
    date_played: string;
};


export type GamePlayers = {
    player1Id: number;
    player2Id: number;
};

//types/matchHistory.ts
export interface MatchHistoryRecord {
    id: number;
    game_id: number;
    user_id: number;
    opponent_id: number;
    user_score: number;
    opponent_score: number;
    result: 'win' | 'loss';
    duration: number;
    date_played: string;
}

//types/session.ts
export type Session = {
  id: number;
  user_id: number;
  token: string;
  created_at: string;
  expires_at: string;
};

//types/team.ts
export interface TeamStats {
    id: number;
    members: string;
    victories: number;
    tournaments_won: number;
    defeats: number;
    win_rate: number;
}

//types/tournament.ts
export interface Tournament {
    id: number;
    name: string;
    team_winner: string;
    team_victories: number;
    size: number;
    date_created: string;
}

//types/user.ts
export type User = {
    id: number;
    name: string;
    username: string;
    team: string;
    password: string;
    display_name?: string;
    email?: string;
    avatar_url: string;
    online_status: number;
    last_seen: string;
    created_at: string;
};

//types/userStats.ts
export type MatchResult = 'win' | 'loss';


export interface UserMatch {
    result: MatchResult;
    match_duration: number;    
    goals_scored: number;
    goals_conceded: number;
    date_played: string;     
}


export type UserStats = {
    user_id: number;
    matches_played: number;
    matches_won: number;
    matches_lost: number;
    points_scored: number;
    points_conceded: number;
    total_play_time: number;
    win_rate: number;
    tournaments_played: number;
    tournaments_won: number;
};

//server.ts
import Fastify from 'fastify';
import fastifyCors from '@fastify/cors';
import fastifyStatic from '@fastify/static';
import path from 'path';
import fs from 'fs';


import { userRoutes } from './routes/user.js';
import { tournamentRoutes } from './routes/tournamentRoutes.js';
import { registerTeamRoutes } from './routes/teamRoutes.js';
import { gameRoutes } from './routes/gameRoutes.js';
import { statsRoutes } from './routes/statsRoutes.js';
import { authRoutes } from './routes/authRoutes.js';
import { matchHistoryRoutes } from './routes/matchHistoryRoutes.js';
import { userProfileRoutes } from './routes/userProfileRoutes.js';
import { friendsRoutes } from './routes/friendsRoutes.js';


import '../backend/db/database.js';


const keyPath = path.join(process.cwd(), 'certs', 'key.pem');
const certPath = path.join(process.cwd(), 'certs', 'cert.pem');


const fastify = Fastify({
logger: true,
https: {
    key: fs.readFileSync(keyPath),
    cert: fs.readFileSync(certPath),
},
});


await fastify.register(fastifyCors, {
origin: true,
});


const pagesPath = path.join(process.cwd(), 'dist', 'frontend', 'pages');
console.log('Serving pages from:', pagesPath);


fastify.register(fastifyStatic, {
root: pagesPath,
prefix: '/',
index: ['index.html'],
});


fastify.register(userRoutes);
fastify.register(tournamentRoutes);
fastify.register(registerTeamRoutes);
fastify.register(gameRoutes);
fastify.register(statsRoutes);
fastify.register(authRoutes);
fastify.register(matchHistoryRoutes);
fastify.register(userProfileRoutes);
fastify.register(friendsRoutes);


const start = async () => {
try {
    await fastify.listen({ port: 3000, host: '0.0.0.0' });
    console.log('九 Server running at https://localhost:3000');
} catch (err) {
    fastify.log.error(err);
    process.exit(1);
}
};


start();

// renderProfilePage/api.ts
import { Friend, Match, Profile, Stats } from './types.js';
import { state } from './state.js';
import { DEFAULT_STATS } from './types.js';


async function apiGet<T>(url: string): Promise<T> {
  const res = await fetch(url, { headers: { Authorization: `Bearer ${state.token}` } });
  if (!res.ok) throw new Error(`${res.status} ${await res.text()}`);
  return res.json();
}


async function apiSend<T>(url: string, method: string, body?: object): Promise<T> {
  const res = await fetch(url, {
    method,
    headers: {
      Authorization: `Bearer ${state.token}`,
      'Content-Type': 'application/json',
    },
    body: body ? JSON.stringify(body) : undefined,
  });
  if (!res.ok) throw new Error(`${res.status} ${await res.text()}`);
  return res.json();
}


export async function loadProfile(): Promise<Profile> {
  return apiGet<Profile>('/api/profile');
}


export async function loadStats(userId: number): Promise<Stats> {
  try {
    const json = await apiGet<any>(`/stats/${userId}`);
    return {
      matches_played: json.matches_played ?? 0,
      matches_won: json.matches_won ?? 0,
      matches_lost: json.matches_lost ?? 0,
      win_rate: json.win_rate ?? 0,
      points_scored: json.points_scored ?? 0,
      points_conceded: json.points_conceded ?? 0,
      tournaments_won: json.tournaments_won ?? 0,
    };
  } catch {
    return DEFAULT_STATS;
  }
}


export async function loadHistory(): Promise<Match[]> {
  try {
    return await apiGet<Match[]>('/api/match-history');
  } catch {
    return [];
  }
}


export async function loadFriends(): Promise<Friend[]> {
  try {
    const data = await apiGet<any>('/api/friends');
    if (Array.isArray(data)) return data as Friend[];
    if (Array.isArray(data?.friends)) return data.friends as Friend[];
    if (Array.isArray(data?.data)) return data.data as Friend[];
    return [];
  } catch {
    return [];
  }
}


export async function updateProfile(payload: {
  username: string;
  display_name?: string;
  email?: string;
  avatar_url?: string;
}): Promise<Partial<Profile>> {
  return apiSend<Partial<Profile>>('/api/profile', 'PUT', payload);
}


export async function changePassword(current_password: string, new_password: string): Promise<void> {
  await apiSend<void>('/api/profile/change-password', 'POST', { current_password, new_password });
}


export async function addFriendApi(username: string): Promise<void> {
  await apiSend<void>('/api/friends/request', 'POST', { friendUsername: username });
}


export async function removeFriendApi(friendId: string): Promise<void> {
  await apiSend<void>(`/api/friends/${friendId}`, 'DELETE');
}

// renderProfilePage/charts.ts
import { state } from './state.js';


export function renderWinRateChart() {
  const canvas = document.getElementById('winRateChart') as HTMLCanvasElement | null;
  if (!canvas) return;
  const ctx = canvas.getContext('2d'); if (!ctx) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const winRate = (state.stats.win_rate || 0) * 100;


  const cx = canvas.width / 2, cy = canvas.height / 2, r = 60, ir = 35;
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, (winRate / 100) * 2 * Math.PI);
  ctx.arc(cx, cy, ir, (winRate / 100) * 2 * Math.PI, 0, true);
  ctx.fillStyle = '#28a745'; ctx.fill();


  ctx.beginPath();
  ctx.arc(cx, cy, r, (winRate / 100) * 2 * Math.PI, 2 * Math.PI);
  ctx.arc(cx, cy, ir, 2 * Math.PI, (winRate / 100) * 2 * Math.PI, true);
  ctx.fillStyle = '#dc3545'; ctx.fill();


  ctx.fillStyle = '#333'; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center';
  ctx.fillText(`${winRate.toFixed(1)}%`, cx, cy + 5);
}


export function renderPerformanceChart() {
  const canvas = document.getElementById('performanceChart') as HTMLCanvasElement | null;
  if (!canvas) return;
  const ctx = canvas.getContext('2d'); if (!ctx) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const matches = state.history.slice(-10).reverse();
  if (!matches.length) return;
  const barW = canvas.width / matches.length - 5;
  const maxScore = Math.max(...matches.map(m => m.user_score), 20);
  matches.forEach((m, i) => {
    const h = (m.user_score / maxScore) * (canvas.height - 40);
    const x = i * (barW + 5), y = canvas.height - h - 20;
    ctx.fillStyle = m.result === 'win' ? '#28a745' : '#dc3545';
    ctx.fillRect(x, y, barW, h);
    ctx.fillStyle = '#333'; ctx.font = '10px Arial'; ctx.textAlign = 'center';
    ctx.fillText(String(m.user_score), x + barW / 2, canvas.height - 5);
  });
}


export function renderScoreDistribution() {
  const canvas = document.getElementById('scoreDistribution') as HTMLCanvasElement | null;
  if (!canvas) return;
  const ctx = canvas.getContext('2d'); if (!ctx) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const scores = state.history.map(m => m.user_score);
  if (!scores.length) return;
  const buckets = Array(6).fill(0);
  for (const s of scores) buckets[Math.min(Math.floor(s / 4), 5)]++;
  const maxCount = Math.max(...buckets, 1);
  const barW = canvas.width / buckets.length - 5;
  buckets.forEach((count, i) => {
    const h = (count / maxCount) * (canvas.height - 40);
    const x = i * (barW + 5), y = canvas.height - h - 20;
    ctx.fillStyle = '#17a2b8'; ctx.fillRect(x, y, barW, h);
    ctx.fillStyle = '#333'; ctx.font = '10px Arial'; ctx.textAlign = 'center';
    const label = i === 5 ? '20+' : `${i * 4}-${i * 4 + 3}`; ctx.fillText(label, x + barW / 2, canvas.height - 5);
  });
}


export function renderTimeAnalysisChart() {
  const canvas = document.getElementById('timeAnalysisChart') as HTMLCanvasElement | null;
  if (!canvas) return;
  const ctx = canvas.getContext('2d'); if (!ctx) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);


  const hourly = Array(24).fill(0);
  const wins = Array(24).fill(0);
  for (const m of state.history) {
    const h = new Date(m.date_played).getHours();
    hourly[h]++; if (m.result === 'win') wins[h]++;
  }
  const max = Math.max(...hourly, 1);
  const barW = canvas.width / 24 - 1;
  for (let h = 0; h < 24; h++) {
    const games = hourly[h]; const rate = games ? wins[h] / games : 0;
    const bh = (games / max) * (canvas.height - 30);
    const x = h * (barW + 1), y = canvas.height - bh - 20;
    const g = Math.floor(rate * 255), r = Math.floor((1 - rate) * 255);
    ctx.fillStyle = `rgb(${r},${g},0)`; ctx.fillRect(x, y, barW, bh);
    if (h % 4 === 0) {
      ctx.fillStyle = '#666'; ctx.font = '10px Arial'; ctx.textAlign = 'center';
      ctx.fillText(`${h}h`, x + barW / 2, canvas.height - 5);
    }
  }
}


export function renderTrendsChart() {
  const canvas = document.getElementById('trendsChart') as HTMLCanvasElement | null;
  if (!canvas) return;
  const ctx = canvas.getContext('2d'); if (!ctx) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);


  const padding = 40, cw = canvas.width - 2 * padding, ch = canvas.height - 2 * padding;
  if (state.history.length < 2) {
    ctx.fillStyle = '#666'; ctx.font = '16px Arial'; ctx.textAlign = 'center';
    ctx.fillText('Not enough data for trend analysis', canvas.width / 2, canvas.height / 2);
    return;
  }
  const trend: Array<{ x: number; y: number }> = [];
  let wins = 0;
  state.history.forEach((m, i) => {
    if (m.result === 'win') wins++;
    const wr = (wins / (i + 1)) * 100;
    trend.push({ x: padding + (i / (state.history.length - 1)) * cw, y: padding + (1 - wr / 100) * ch });
  });
  ctx.strokeStyle = '#007bff'; ctx.lineWidth = 2; ctx.beginPath();
  trend.forEach((p, i) => (i ? ctx.lineTo(p.x, p.y) : ctx.moveTo(p.x, p.y)));
  ctx.stroke();
  ctx.fillStyle = '#666'; ctx.font = '12px Arial'; ctx.textAlign = 'left';
  ctx.fillText('100%', 5, padding + 10); ctx.fillText('0%', 5, padding + ch);
}


export function renderWeeklyChart() {
  const canvas = document.getElementById('weeklyChart') as HTMLCanvasElement | null;
  if (!canvas) return;
  const ctx = canvas.getContext('2d'); if (!ctx) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);


  const now = new Date();
  const weeks = Array.from({ length: 4 }, (_, idx) => {
    const i = 3 - idx;
    const start = new Date(now); start.setDate(now.getDate() - (i + 1) * 7);
    const end = new Date(now); end.setDate(now.getDate() - i * 7);
    const matches = state.history.filter(m => {
      const d = new Date(m.date_played);
      return d >= start && d < end;
    });
    const wins = matches.filter(m => m.result === 'win').length;
    return { label: `Week ${idx + 1}`, games: matches.length, wins };
  });


  if (weeks.every(w => w.games === 0)) {
    ctx.fillStyle = '#666'; ctx.font = '14px Arial'; ctx.textAlign = 'center';
    ctx.fillText('No matches in last 4 weeks', canvas.width / 2, canvas.height / 2);
    return;
  }


  const barW = canvas.width / weeks.length - 10;
  const max = Math.max(...weeks.map(w => w.games), 1);
  weeks.forEach((w, i) => {
    const h = (w.games / max) * (canvas.height - 40);
    const x = i * (barW + 10) + 5, y = canvas.height - h - 20;
    ctx.fillStyle = '#007bff'; ctx.fillRect(x, y, barW * 0.6, h);
    const wh = (w.wins / max) * (canvas.height - 40);
    ctx.fillStyle = '#28a745'; ctx.fillRect(x + barW * 0.4, canvas.height - wh - 20, barW * 0.6, wh);
    ctx.fillStyle = '#333'; ctx.font = '10px Arial'; ctx.textAlign = 'center';
    ctx.fillText(w.label, x + barW / 2, canvas.height - 5);
  });
}


export function renderActivityHeatmap() {
  const canvas = document.getElementById('activityHeatmap') as HTMLCanvasElement | null;
  if (!canvas) return;
  const ctx = canvas.getContext('2d'); if (!ctx) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);


  // Real activity based on matches in last 7 days
  const days = Array.from({ length: 7 }, (_, i) => {
    const d = new Date(); d.setHours(0,0,0,0); d.setDate(d.getDate() - (6 - i));
    return d;
  });
  const counts = days.map(day => {
    const next = new Date(day); next.setDate(day.getDate() + 1);
    return state.history.filter(m => {
      const d = new Date(m.date_played);
      return d >= day && d < next;
    }).length;
  });
  const max = Math.max(...counts, 1);
  const cw = canvas.width / 7, ch = canvas.height;


  counts.forEach((c, i) => {
    const alpha = c ? (0.2 + 0.8 * (c / max)) : 0.1;
    ctx.fillStyle = `rgba(40,167,69,${alpha})`;
    ctx.fillRect(i * cw, 0, cw - 2, ch - 18);
    const label = days[i].toLocaleDateString(undefined, { weekday: 'short' });
    ctx.fillStyle = '#333'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
    ctx.fillText(label, i * cw + cw / 2, ch - 4);
  });
}


export function renderAllCharts() {
  // Delay to let DOM mount
  setTimeout(() => {
    try {
      renderWinRateChart();
      renderPerformanceChart();
      renderScoreDistribution();
      renderTimeAnalysisChart();
      renderTrendsChart();
      renderWeeklyChart();
      renderActivityHeatmap();
    } catch (e) {
      console.log('Chart error', e);
    }
  }, 50);
}

// renderProfilePage/events.ts
import { loadFriends, changePassword, addFriendApi, removeFriendApi, updateProfile, loadProfile } from './api.js';
import { renderAllCharts } from './charts.js';
import { state } from './state.js';
import { layout, statsOverview, statsPerformance, statsTrends, historyList, historyDetailed, historyAnalysis, friendsList } from './templates.js';
import { gamesThisWeek } from './metrics.js';
import { Profile } from './types.js';


function setHTML(el: HTMLElement, html: string) { el.innerHTML = html; }


function showNotification(message: string, color: string) {
  const el = document.getElementById('notification');
  if (!el) return;
  el.textContent = message;
  (el as HTMLElement).style.backgroundColor = color;
  (el as HTMLElement).style.display = 'block';
  setTimeout(() => ((el as HTMLElement).style.display = 'none'), 3000);
}


function showInlineMessage(id: string, message: string, color: string) {
  const el = document.getElementById(id) as HTMLElement | null;
  if (!el) return;
  el.textContent = message;
  el.style.color = color;
  setTimeout(() => { el.textContent = ''; }, 3000);
}


export function setupFriendHoverEffects() {
  const friendItems = document.querySelectorAll('.friend-item');
  
  friendItems.forEach(item => {
    const removeBtn = item.querySelector('.remove-friend-btn') as HTMLElement;
    
    // Mouse enter
    item.addEventListener('mouseenter', () => {
      if (removeBtn) {
        removeBtn.style.display = 'block';
        (item as HTMLElement).style.backgroundColor = '#f8f9fa';
      }
    });
    
    // Mouse leave 
    item.addEventListener('mouseleave', () => {
      if (removeBtn) {
        removeBtn.style.display = 'none';
        (item as HTMLElement).style.backgroundColor = '#fff';
      }
    });
  });
}


export function render(container: HTMLElement) {
  if (!state.profile) return;
  container.innerHTML = layout(
    state.profile,
    state.stats,
    state.history,
    state.friends,
    state.activeStatsTab,
    state.activeHistoryView,
    state.editMode
  );
  // Inject tab content after layout renders
  const statsEl = document.getElementById('stats-content')!;
  const histEl = document.getElementById('history-content')!;
  if (state.activeStatsTab === 'overview') statsEl.innerHTML = statsOverview(state.stats, state.history);
  if (state.activeStatsTab === 'performance') statsEl.innerHTML = statsPerformance(state.stats, state.history);
  if (state.activeStatsTab === 'trends') {
    statsEl.innerHTML = statsTrends(state.stats).replace('Games/Week', `Games/Week`).replace('value: String(gamesThisWeek([]))', '');
    // quick patch: no fake data, charts will show real; label is static
  }
  if (state.activeHistoryView === 'list') histEl.innerHTML = historyList(state.history);
  if (state.activeHistoryView === 'detailed') histEl.innerHTML = historyDetailed(state.history);
  if (state.activeHistoryView === 'analysis') histEl.innerHTML = historyAnalysis(state.history);
  renderAllCharts();
}


export function setupRemoveFriendEvents() {
  document.querySelectorAll('.remove-friend-btn').forEach(btn => {
    btn.addEventListener('click', async (e) => {
      e.stopPropagation(); // Prevent triggering parent click
      
      const target = e.target as HTMLElement;
      const friendId = target.dataset.friendId;
      const friendName = target.dataset.friendName;
      
      if (!friendId || !friendName) return;
      
      // Confirmation dialog
      if (confirm(`Are you sure you want to remove ${friendName} from your friends?`)) {
        try {
          await removeFriendApi(friendId);
          showNotification(`${friendName} removed from friends list`, '#28a745');
          
          // Reload friends list and re-render
          const friends = await loadFriends();
          state.friends = friends;
          rerenderFriends();
        } catch (err) {
          showNotification('Error while removing friend', '#dc3545');
        }
      }
    });
  });
}


export function setupEvents(container: HTMLElement) {
  container.addEventListener('click', async (e) => {
    const t = e.target as HTMLElement;
    const id = t.id;
    const action = t.dataset.action;


    if (id === 'edit-btn') {
      state.editMode = true; render(container);
      return;
    }
    if (id === 'cancel-btn') {
      state.editMode = false; render(container);
      return;
    }
    if (id === 'save-btn') {
      const username = (document.getElementById('username-input') as HTMLInputElement)?.value?.trim();
      const display_name = (document.getElementById('display-input') as HTMLInputElement)?.value?.trim();
      const email = (document.getElementById('email-input') as HTMLInputElement)?.value?.trim();
      const avatar_url = (document.getElementById('avatar-preview') as HTMLImageElement)?.src;
      if (!username || username.length < 3) {
        const err = document.getElementById('save-error'); if (err) err.textContent = 'Username must be at least 3 characters';
        return;
      }
      try {
        // Send patch
        const patch = await updateProfile({ username, display_name, email, avatar_url });


        // Prefer a fresh full profile from the server to avoid missing fields
        let full: Profile | null = null;
        try { full = await loadProfile(); } catch { /* ignore */ }


        // Merge as fallback if backend doesn't return full profile
        state.profile = full ? full : { ...(state.profile || {}), ...(patch as any) };


        state.editMode = false;
        render(container);
        showNotification('Profile updated successfully!', '#28a745');
      } catch (err: any) {
        const errEl = document.getElementById('save-error');
        if (errEl) errEl.textContent = err?.message || 'Failed to save profile';
      }
      return;
    }
    if (id === 'pass-btn') {
      document.getElementById('pass-modal')!.style.display = 'flex';
      return;
    }
    if (id === 'avatar-btn') {
      document.getElementById('avatar-modal')!.style.display = 'flex';
      return;
    }
    if (id === 'avatar-modal-close') {
      document.getElementById('avatar-modal')!.style.display = 'none';
      return;
    }
    if (id === 'friend-add') {
      const input = document.getElementById('friend-input') as HTMLInputElement;
      const username = input.value.trim();
      
      if (!username) {
        showInlineMessage('friend-msg', 'Por favor, insira um username', '#dc3545');
        return;
      }
      
      const addBtn = t as HTMLButtonElement;
      addBtn.disabled = true;
      addBtn.textContent = '낍 A adicionar...';
      
      try {
        await addFriendApi(username);
        input.value = '';
        showInlineMessage('friend-msg', `Pedido de amizade enviado para ${username}!`, '#28a745');
        
        // Reload friends list and re-render after a short delay to allow backend processing
        setTimeout(async () => {
          try {
            const friends = await loadFriends();
            state.friends = friends;
            rerenderFriends();
          } catch (err) {
            console.error('Erro ao recarregar amigos:', err);
          }
        }, 1000);
        
      } catch (err: any) {
        const errorMsg = err?.message || 'Erro ao adicionar amigo';
        showInlineMessage('friend-msg', errorMsg, '#dc3545');
      } finally {
        addBtn.disabled = false;
        addBtn.textContent = '俱 Add';
      }
      return;
    }
    if (action === 'remove-friend' && t.dataset.id) {
      try {
        await removeFriendApi(t.dataset.id);
        showNotification('Friend removed successfully!', '#28a745');
      } catch {
        showNotification('Failed to remove friend', '#dc3545');
      }
      return;
    }
    // Avatar grid selection
    if (t.closest('.avatar-option')) {
      const option = t.closest('.avatar-option') as HTMLElement;
      document.querySelectorAll('.avatar-option').forEach(o => (o as HTMLElement).style.borderColor = 'transparent');
      option.style.borderColor = '#007bff';
      const confirm = document.getElementById('avatar-confirm') as HTMLButtonElement;
      confirm.disabled = false; confirm.style.opacity = '1';
      confirm.onclick = () => {
        const selected = option.getAttribute('data-avatar');
        const preview = document.getElementById('avatar-preview') as HTMLImageElement;
        if (selected && preview) preview.src = selected;
        document.getElementById('avatar-modal')!.style.display = 'none';
      };
    }


    // Tabs
    if (t.classList.contains('stats-tab')) {
      state.activeStatsTab = (t.dataset.tab as any) ?? 'overview';
      render(container);
      return;
    }
    if (t.classList.contains('history-tab')) {
      state.activeHistoryView = (t.dataset.view as any) ?? 'list';
      render(container);
      return;
    }
  });


  container.addEventListener('submit', async (e) => {
    const form = e.target as HTMLFormElement;
    if (form.id === 'pass-form') {
      e.preventDefault();
      const cur = (document.getElementById('pass-cur') as HTMLInputElement).value;
      const np = (document.getElementById('pass-new') as HTMLInputElement).value;
      const cf = (document.getElementById('pass-conf') as HTMLInputElement).value;
      if (np !== cf) {
        const err = document.getElementById('pass-error'); if (err) err.textContent = 'Passwords do not match';
        return;
      }
      try {
        await changePassword(cur, np);
        document.getElementById('pass-modal')!.style.display = 'none';
        (document.getElementById('pass-form') as HTMLFormElement).reset();
        showNotification('Password updated successfully!', '#28a745');
      } catch (err: any) {
        const el = document.getElementById('pass-error'); if (el) el.textContent = err?.message || 'Failed to update password';
      }
    }
  });
  // Initial friend hover and remove setup
  setTimeout(() => {
    setupFriendHoverEffects();
    setupRemoveFriendEvents();
  }, 100);
}


export function rerenderFriends() {
  const fc = document.getElementById('friends-container');
  if (fc) setHTML(fc, friendsList(state.friends));
  // Re-setup hover and remove events
  setupFriendHoverEffects();
  setupRemoveFriendEvents();
}

// renderProfilePage/metrics.ts
import { Match, Stats } from './types.js';


export function averageScore(history: Match[]): number {
  if (!history.length) return 0;
  const total = history.reduce((s, m) => s + m.user_score, 0);
  return total / history.length;
}


export function longestWinStreak(history: Match[]): number {
  let max = 0, cur = 0;
  for (const m of history) {
    if (m.result === 'win') { cur++; max = Math.max(max, cur); } else { cur = 0; }
  }
  return max;
}


export function consistencyScore(history: Match[]): number {
  if (!history.length) return 0;
  const scores = history.map(m => m.user_score);
  const avg = scores.reduce((a, b) => a + b, 0) / scores.length;
  if (avg <= 0) return 0;
  const variance = scores.reduce((sum, s) => sum + Math.pow(s - avg, 2), 0) / scores.length;
  const std = Math.sqrt(variance);
  return Math.max(0, Math.floor(100 - (std / avg) * 100));
}


export function clutchFactor(history: Match[]): number {
  const close = history.filter(m => Math.abs(m.user_score - m.opponent_score) <= 3);
  if (!close.length) return 0;
  const wins = close.filter(m => m.result === 'win').length;
  return Math.floor((wins / close.length) * 100);
}


export function dominanceRating(history: Match[]): number {
  if (!history.length) return 0;
  const domWins = history.filter(m => m.result === 'win' && (m.user_score - m.opponent_score) >= 7).length;
  return Math.floor((domWins / history.length) * 100);
}


export function comebackWins(history: Match[]): number {
  return history.filter(m =>
    m.result === 'win' && m.user_score > m.opponent_score && m.opponent_score > m.user_score * 0.7
  ).length;
}


export function bestPerformance(history: Match[]): { score: number | null, match?: Match } {
  if (!history.length) return { score: null };
  const best = history.reduce((b, c) => (c.user_score > b.user_score ? c : b));
  return { score: best.user_score, match: best };
}


export function gamesThisWeek(history: Match[]): number {
  const weekAgo = new Date();
  weekAgo.setDate(weekAgo.getDate() - 7);
  return history.filter(m => new Date(m.date_played) >= weekAgo).length;
}


export function mostActiveTime(history: Match[]): 'Morning' | 'Afternoon' | 'Evening' | 'Night' | 'N/A' {
  if (!history.length) return 'N/A';
  const buckets = { morning: 0, afternoon: 0, evening: 0, night: 0 };
  for (const m of history) {
    const h = new Date(m.date_played).getHours();
    if (h >= 6 && h < 12) buckets.morning++;
    else if (h >= 12 && h < 18) buckets.afternoon++;
    else if (h >= 18 && h < 24) buckets.evening++;
    else buckets.night++;
  }
  const arr = Object.entries(buckets).sort((a, b) => b[1] - a[1]);
  const key = (arr[0]?.[0] ?? 'morning') as keyof typeof buckets;
  return key.charAt(0).toUpperCase() + key.slice(1) as any;
}


export function bestPlayingDay(history: Match[]): string {
  if (!history.length) return 'N/A';
  const days = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
  const dayStats: Record<string, { wins: number; total: number }> = {};
  for (const m of history) {
    const d = days[new Date(m.date_played).getDay()];
    dayStats[d] ??= { wins: 0, total: 0 };
    dayStats[d].total++;
    if (m.result === 'win') dayStats[d].wins++;
  }
  const best = Object.entries(dayStats)
    .map(([day, s]) => ({ day, rate: s.total ? s.wins / s.total : 0 }))
    .sort((a, b) => b.rate - a.rate)[0];
  return best?.day ?? 'N/A';
}


export function currentMomentum(history: Match[]): 'Hot Streak' | 'Positive' | 'Stable' | 'Recovery Mode' | 'Building' {
  if (history.length < 5) return 'Building';
  const recent = history.slice(-5);
  const wins = recent.filter(m => m.result === 'win').length;
  if (wins >= 4) return 'Hot Streak';
  if (wins >= 3) return 'Positive';
  if (wins === 2) return 'Stable';
  return 'Recovery Mode';
}


export function efficiencyScore(stats: Stats): number {
  if (!stats.matches_played) return 0;
  return (stats.points_scored / stats.matches_played) / 2.5;
}


export function opponentAnalysis(history: Match[]): Array<{ id: string; matches: number; winRate: number; record: string }> {
  const opp: Record<string, { wins: number; total: number }> = {};
  for (const m of history) {
    const id = m.opponent_id;
    opp[id] ??= { wins: 0, total: 0 };
    opp[id].total++;
    if (m.result === 'win') opp[id].wins++;
  }
  return Object.entries(opp)
    .map(([id, d]) => ({ id, matches: d.total, winRate: Math.floor((d.wins / d.total) * 100), record: `${d.wins}W-${d.total - d.wins}L` }))
    .sort((a, b) => b.matches - a.matches)
    .slice(0, 5);
}

import { loadFriends, loadHistory, loadProfile, loadStats } from './api.js';
import { renderAllCharts } from './charts.js';
import { setupEvents, rerenderFriends } from './events.js';
import { state } from './state.js';
import { layout, statsOverview, statsPerformance, statsTrends, historyList, historyDetailed, historyAnalysis } from './templates.js';
import { gamesThisWeek } from './metrics.js';


export async function renderProfilePage(container: HTMLElement, onBadgeUpdate?: () => void) {
  const token = localStorage.getItem('authToken');
  if (!token) {
    container.innerHTML = '<p>Please log in to view your profile.</p>';
    return;
  }
  state.token = token;
  state.container = container;
  state.onBadgeUpdate = onBadgeUpdate;


  try {
    const profile = await loadProfile();
    state.profile = profile;


    const [stats, history, friends] = await Promise.all([
      loadStats(profile.id),
      loadHistory(),
      loadFriends(),
    ]);
    state.stats = stats;
    state.history = history;
    state.friends = friends;


    // Initial render
    container.innerHTML = layout(profile, stats, history, friends, state.activeStatsTab, state.activeHistoryView, state.editMode);


    // Inject tab content
    const statsEl = document.getElementById('stats-content')!;
    const histEl = document.getElementById('history-content')!;
    statsEl.innerHTML = statsOverview(state.stats, state.history);
    histEl.innerHTML = state.history.length ? historyList(state.history) :
      '<div style="padding:40px;text-align:center;color:#666;background:#f8f9fa;border-radius:8px"><div style="font-size:48px;margin-bottom:15px">游꿡</div><h4 style="margin:0 0 10px 0">No Match History</h4><p style="margin:0;color:#999">Your game history will appear here once you start playing!</p></div>';


    setupEvents(container);


    setTimeout(async () => {
      const { setupFriendHoverEffects, setupRemoveFriendEvents } = await import('./events.js');
      setupFriendHoverEffects();
      setupRemoveFriendEvents();
    }, 100);
    
    renderAllCharts();


    try { onBadgeUpdate?.(); } catch { /* ignore */ }
  } catch (err: any) {
    container.innerHTML = `<p>${err?.message || 'Error loading profile. Please try again.'}</p>`;
  }
}


// Optional helpers to refresh sections after mutations
export async function refreshFriends() {
  const res = await fetch('/api/friends', { headers: { Authorization: `Bearer ${state.token}` } });
  if (res.ok) {
    state.friends = await res.json();
    rerenderFriends();
    try { state.onBadgeUpdate?.(); } catch { /* ignore */ }
  }
}

// renderProfilePage/state.ts


import { DEFAULT_STATS, Friend, HistoryView, Match, Profile, Stats, StatsTab } from './types.js';


export const state: {
  token: string;
  profile?: Profile;
  stats: Stats;
  history: Match[];
  friends: Friend[];
  editMode: boolean;
  activeStatsTab: StatsTab;
  activeHistoryView: HistoryView;
  onBadgeUpdate?: () => void;
  container?: HTMLElement;
} = {
  token: '',
  stats: DEFAULT_STATS,
  history: [],
  friends: [],
  editMode: false,
  activeStatsTab: 'overview',
  activeHistoryView: 'list',
};

// renderProfilePage/templates.ts
import { AVAILABLE_AVATARS, Friend, Match, Profile, Stats } from './types.js';
import {
  averageScore, bestPerformance, consistencyScore, bestPlayingDay, clutchFactor, currentMomentum,
  dominanceRating, efficiencyScore, gamesThisWeek, longestWinStreak, mostActiveTime, opponentAnalysis
} from './metrics.js';


export function header(profile: Profile, isEdit: boolean): string {
  const avatar = isEdit
    ? `
    <div style="text-align:center;margin-bottom:15px">
      <div style="position:relative;display:inline-block">
        <img id="avatar-preview" src="${profile.avatar_url}" width="100" height="100" style="border-radius:50%;border:3px solid #ddd;object-fit:cover;cursor:pointer" alt="Avatar"/>
        <div id="avatar-overlay" style="position:absolute;inset:0;background:rgba(0,0,0,0.5);border-radius:50%;
                    display:flex;align-items:center;justify-content:center;opacity:0;transition:opacity 0.3s;cursor:pointer">
          <span style="color:white;font-size:14px;font-weight:bold">游닝 Change</span>
        </div>
      </div>
      <div style="margin-top:10px">
        <button id="avatar-btn" type="button" style="background:#17a2b8;color:#fff;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;font-size:12px">
          游닝 Choose Avatar
        </button>
      </div>
    </div>`
    : `
    <div style="text-align:center;margin-bottom:15px">
      <img src="${profile.avatar_url}" width="100" height="100" style="border-radius:50%;border:3px solid #ddd;object-fit:cover" alt="Avatar"/>
    </div>`;


  const createdAtText = profile.created_at ? new Date(profile.created_at).toLocaleDateString() : '';


  return isEdit
    ? `
    <div style="background:#f8f9fa;padding:20px;border-radius:8px;margin:15px 0">
      <div style="display:flex;align-items:flex-start;gap:20px">
        ${avatar}
        <div style="flex:1">
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;margin-bottom:15px">
            <div>
              <label style="display:block;margin-bottom:5px;font-weight:bold">Username:</label>
              <input id="username-input" type="text" value="${profile.username}" required minlength="3" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:4px"/>
              <small style="color:#666">Min 3 characters</small>
            </div>
            <div>
              <label style="display:block;margin-bottom:5px;font-weight:bold">Display Name:</label>
              <input id="display-input" type="text" value="${profile.display_name || profile.name || ''}" required style="width:100%;padding:8px;border:1px solid #ddd;border-radius:4px"/>
              <small style="color:#666">Public name shown in games</small>
            </div>
          </div>
          <div style="margin-bottom:15px">
            <label style="display:block;margin-bottom:5px;font-weight:bold">Email:</label>
            <input id="email-input" type="email" value="${profile.email || ''}" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:4px"/>
            <small style="color:#666">Optional - for account recovery</small>
          </div>
          <div style="display:grid;grid-template-columns:auto auto auto;gap:10px;justify-content:start">
            <button id="save-btn" style="background:#28a745;color:#fff;border:none;padding:10px 20px;border-radius:4px;cursor:pointer;font-weight:bold">游 Save Changes</button>
            <button id="cancel-btn" style="background:#6c757d;color:#fff;border:none;padding:10px 20px;border-radius:4px;cursor:pointer">仇 Cancel</button>
            <button id="pass-btn" style="background:#ffc107;color:#000;border:none;padding:10px 20px;border-radius:4px;cursor:pointer">游 Change Password</button>
          </div>
          <div id="save-error" style="color:#dc3545;margin-top:10px;font-size:14px"></div>
        </div>
      </div>
      <div style="margin-top:15px;padding-top:15px;border-top:1px solid #ddd">
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:15px;font-size:14px">
          <div><strong>Team:</strong> ${profile.team || ''}</div>
          <div><strong>Member since:</strong> ${createdAtText}</div>
          <div><strong>Last seen:</strong> ${profile.last_seen ? new Date(profile.last_seen).toLocaleString() : ''}</div>
          <div><strong>Status:</strong> ${profile.online_status ? '游릭 Online' : '游댮 Offline'}</div>
        </div>
      </div>
    </div>`
    : `
    <div style="background:#f8f9fa;padding:20px;border-radius:8px;margin:15px 0">
      <div style="display:flex;align-items:center;gap:20px">
        ${avatar}
        <div style="flex:1">
          <div style="display:flex;align-items:center;gap:10px;margin-bottom:10px">
            <h3 style="margin:0;color:#333">@${profile.username}</h3>
            <button id="edit-btn" title="Edit profile" style="background:none;border:none;cursor:pointer;font-size:18px;color:#007bff">游둙勇</button>
          </div>
          <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:10px;margin-bottom:15px">
            <div><strong>Display Name:</strong> ${profile.display_name || profile.name || ''}</div>
            <div><strong>Email:</strong> ${profile.email || 'Not provided'}</div>
            <div><strong>Team:</strong> ${profile.team || ''}</div>
            <div><strong>Member since:</strong> ${createdAtText}</div>
          </div>
          <div style="font-size:12px;color:#666">
            <strong>Status:</strong> ${profile.online_status ? '游릭 Online' : '游댮 Offline'}  
            <strong>Last seen:</strong> ${profile.last_seen ? new Date(profile.last_seen).toLocaleString() : ''}
          </div>
        </div>
      </div>
    </div>`;
}


export function friendsList(friends: Friend[]): string {
  if (!friends.length) {
    return '<div style="padding:20px;text-align:center;color:#666;background:#f8f9fa;border-radius:8px;font-size:14px">No friends added yet. Add some friends to see them here!</div>';
  }
  
  return friends.map(f => `
    <div class="friend-item" data-friend-id="${f.friend_id || f.id}" data-friend-name="${f.display_name || f.name || f.username}"
         style="display:flex;align-items:center;gap:10px;padding:10px;background:#fff;
                border-radius:8px;margin-bottom:10px;box-shadow:0 2px 5px rgba(0,0,0,0.1);
                position:relative;transition:all 0.2s;cursor:pointer">
      <img src="${f.avatar_url || '/assets/avatar/default.png'}" width="40" height="40" 
           style="border-radius:50%;object-fit:cover;border:2px solid ${f.online_status ? '#28a745' : '#6c757d'}" alt="Avatar"/>
      <div style="flex:1">
        <div style="font-weight:bold;color:#333">${f.display_name || f.name || f.username}</div>
        <div style="font-size:12px;color:#666">@${f.username}  ${f.team || 'No team'}</div>
        <div style="font-size:11px;color:${f.online_status ? '#28a745' : '#6c757d'}">
          ${f.online_status ? '游릭 Online' : '游댮 Offline'}
        </div>
      </div>
      <button class="remove-friend-btn" data-friend-id="${f.friend_id || f.id}" 
              data-friend-name="${f.display_name || f.name || f.username}"
              title="Remove friend"
              style="display:none;background:#dc3545;color:#fff;border:none;border-radius:50%;
                     width:24px;height:24px;cursor:pointer;font-size:12px;position:absolute;
                     top:8px;right:8px">
        칑
      </button>
    </div>
  `).join('');
}


export function statsOverview(stats: Stats, history: Match[]): string {
  const wr = (stats.win_rate * 100).toFixed(1);
  const kd = stats.points_conceded ? (stats.points_scored / stats.points_conceded).toFixed(2) : String(stats.points_scored);
  const avgP = stats.matches_played ? (stats.points_scored / stats.matches_played).toFixed(1) : '0';
  const avgC = stats.matches_played ? (stats.points_conceded / stats.matches_played).toFixed(1) : '0';
  const ws = longestWinStreak(history);
  const best = bestPerformance(history);


  return `
    <div>
      <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:20px;margin-bottom:30px">
        ${[
          { label: 'Total Matches', value: stats.matches_played, color: '#007bff', icon: '游꿡', sub: 'Games played' },
          { label: 'Win Rate', value: `${wr}%`, color: parseFloat(wr) >= 50 ? '#28a745' : '#dc3545', icon: '游끥', sub: `${stats.matches_won}W / ${stats.matches_lost}L` },
          { label: 'Score Ratio', value: kd, color: parseFloat(kd) >= 1 ? '#28a745' : '#ffc107', icon: '丘', sub: 'Scored / Conceded' },
          { label: 'Tournaments Won', value: stats.tournaments_won || 0, color: '#fd7e14', icon: '游끤', sub: 'Titles' }
        ].map(s => `
          <div style="background:linear-gradient(135deg, ${s.color}15, ${s.color}05);padding:20px;border-radius:12px;border-left:4px solid ${s.color}">
            <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
              <div style="font-size:28px;font-weight:bold;color:${s.color}">${s.value}</div>
              <div style="font-size:24px;opacity:0.7">${s.icon}</div>
            </div>
            <div style="font-size:14px;font-weight:bold;color:#333;margin-bottom:2px">${s.label}</div>
            <div style="font-size:12px;color:#666">${s.sub}</div>
          </div>
        `).join('')}
      </div>


      <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:30px">
        <div style="background:#f8f9fa;padding:20px;border-radius:12px">
          <h4 style="margin:0 0 15px 0;color:#333;display:flex;align-items:center;gap:8px"><span>游늵</span> Scoring Statistics</h4>
          <div>
            ${[
              ['Total Points Scored', `<strong style="color:#28a745">${stats.points_scored}</strong>`],
              ['Total Points Conceded', `<strong style="color:#dc3545">${stats.points_conceded}</strong>`],
              ['Avg Points per Match', `<strong style="color:#007bff">${avgP}</strong>`],
              ['Avg Conceded per Match', `<strong style="color:#ffc107">${avgC}</strong>`],
            ].map(([l, v], i, arr) => `
              <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 0;${i < arr.length - 1 ? 'border-bottom:1px solid #e9ecef' : ''}">
                <span style="color:#666">${l}</span>${v}
              </div>
            `).join('')}
          </div>
        </div>


        <div style="background:#f8f9fa;padding:20px;border-radius:12px">
          <h4 style="margin:0 0 15px 0;color:#333;display:flex;align-items:center;gap:8px"><span>游꿢</span> Performance Metrics</h4>
          <div>
            ${[
              ['Current Win Streak', `<strong style="color:${ws > 0 ? '#28a745' : '#dc3545'}">${ws}</strong>`],
              ['Best Match Score', `<strong style="color:#007bff">${best.score ?? 'N/A'}</strong>`],
              ['Games This Week', `<strong style="color:#17a2b8">${gamesThisWeek(history)}</strong>`],
              ['Favorite Time', `<strong style="color:#6f42c1">${mostActiveTime(history)}</strong>`],
            ].map(([l, v], i, arr) => `
              <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 0;${i < arr.length - 1 ? 'border-bottom:1px solid #e9ecef' : ''}">
                <span style="color:#666">${l}</span>${v}
              </div>
            `).join('')}
          </div>
        </div>
      </div>


      <div style="background:#f8f9fa;padding:20px;border-radius:12px;margin-bottom:20px">
        <h4 style="margin:0 0 15px 0;color:#333;display:flex;align-items:center;gap:8px"><span>游늳</span> Win Rate</h4>
        <canvas id="winRateChart" width="400" height="200" style="width:100%;height:200px;background:#fff;border-radius:8px"></canvas>
      </div>
    </div>
  `;
}


export function statsPerformance(stats: Stats, history: Match[]): string {
  const avg = averageScore(history).toFixed(1);
  const cons = consistencyScore(history);
  const clutch = clutchFactor(history);
  const dom = dominanceRating(history);
  const eff = efficiencyScore(stats).toFixed(1);
  return `
    <div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:30px">
        <div style="background:#f8f9fa;padding:20px;border-radius:12px">
          <h4 style="margin:0 0 15px 0;color:#333">游늵 Recent Match Scores</h4>
          <canvas id="performanceChart" width="300" height="200" style="width:100%;height:200px;background:#fff;border-radius:8px"></canvas>
        </div>
        <div style="background:#f8f9fa;padding:20px;border-radius:12px">
          <h4 style="margin:0 0 15px 0;color:#333">游끥 Performance Rankings</h4>
          ${[
            { label: 'Average Score', value: avg, desc: 'Points per match', color: parseFloat(avg) >= 10 ? '#28a745' : '#ffc107', icon: '丘' },
            { label: 'Consistency', value: `${cons}%`, desc: 'Performance stability', color: cons >= 70 ? '#28a745' : cons >= 50 ? '#ffc107' : '#dc3545', icon: '游꿢' },
            { label: 'Clutch Factor', value: `${clutch}%`, desc: 'Close game wins', color: clutch >= 60 ? '#28a745' : '#ffc107', icon: '游댠' },
            { label: 'Dominance', value: `${dom}%`, desc: 'Big-margin wins', color: '#6f42c1', icon: '游녬' },
            { label: 'Efficiency', value: eff, desc: 'Performance per match', color: '#e83e8c', icon: '丘' },
          ].map(r => `
            <div style="display:flex;align-items:center;gap:12px;padding:10px;background:#fff;border-radius:8px;border-left:4px solid ${r.color};margin-bottom:10px">
              <div style="font-size:20px">${r.icon}</div>
              <div style="flex:1">
                <div style="font-weight:bold;color:#333">${r.label}</div>
                <div style="font-size:12px;color:#666">${r.desc}</div>
              </div>
              <div style="font-weight:bold;color:${r.color}">${r.value}</div>
            </div>`).join('')}
        </div>
      </div>


      <div style="background:#f8f9fa;padding:20px;border-radius:12px;margin-bottom:20px">
        <h4 style="margin:0 0 15px 0;color:#333">游댠 Activity Heatmap (7 days)</h4>
        <canvas id="activityHeatmap" width="600" height="100" style="width:100%;height:100px;background:#fff;border-radius:8px"></canvas>
      </div>
    </div>
  `;
}


export function statsTrends(stats: Stats): string {
  return `
    <div>
      <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:15px;margin-bottom:30px">
        ${[
          { label: 'Win Rate', value: `${(stats.win_rate * 100).toFixed(1)}%`, color: '#28a745', icon: '游끥', period: 'current' },
          { label: 'Avg Score', value: (stats.matches_played ? (stats.points_scored / stats.matches_played).toFixed(1) : '0'), color: '#007bff', icon: '游늵', period: 'per match' },
          { label: 'Games/Week', value: String(gamesThisWeek([])), color: '#17a2b8', icon: '游꿡', period: 'this week' }, /* updated at runtime in index */
          { label: 'Total Matches', value: String(stats.matches_played), color: '#6f42c1', icon: '游늳', period: 'all time' },
        ].map(t => `
          <div style="background:linear-gradient(135deg, ${t.color}15, ${t.color}05);padding:18px;border-radius:12px;border-left:4px solid ${t.color}">
            <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
              <span style="font-size:20px">${t.icon}</span>
              <div style="text-align:right"><div style="font-size:16px;font-weight:bold;color:${t.color}">${t.value}</div></div>
            </div>
            <div style="font-size:14px;font-weight:bold;color:#333">${t.label}</div>
            <div style="font-size:12px;color:#666">${t.period}</div>
          </div>
        `).join('')}
      </div>


      <div style="background:#f8f9fa;padding:20px;border-radius:12px;margin-bottom:30px">
        <h4 style="margin:0 0 15px 0;color:#333">游늳 Win Rate Progression</h4>
        <canvas id="trendsChart" width="800" height="300" style="width:100%;height:300px;background:#fff;border-radius:8px"></canvas>
      </div>


      <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px">
        <div style="background:#f8f9fa;padding:20px;border-radius:12px">
          <h4 style="margin:0 0 15px 0;color:#333">游늰 Weekly Breakdown</h4>
          <canvas id="weeklyChart" width="300" height="200" style="width:100%;height:200px;background:#fff;border-radius:8px"></canvas>
        </div>
        <div style="background:#f8f9fa;padding:20px;border-radius:12px">
          <h4 style="margin:0 0 15px 0;color:#333">낋 Time-based Performance</h4>
          <canvas id="timeAnalysisChart" width="800" height="250" style="width:100%;height:250px;background:#fff;border-radius:8px"></canvas>
        </div>
      </div>
    </div>
  `;
}


export function historyList(history: Match[]): string {
  const recent = history.slice(0, 10);
  return `
    <div>
      <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:15px;margin-bottom:25px">
        <div style="background:linear-gradient(135deg, #28a74515, #28a74505);padding:15px;border-radius:10px;border-left:4px solid #28a745;text-align:center">
          <div style="font-size:20px;font-weight:bold;color:#28a745">${history.filter(m => m.result === 'win').length}</div>
          <div style="font-size:12px;color:#666">Total Wins</div>
        </div>
        <div style="background:linear-gradient(135deg, #dc354515, #dc354505);padding:15px;border-radius:10px;border-left:4px solid #dc3545;text-align:center">
          <div style="font-size:20px;font-weight:bold;color:#dc3545">${history.filter(m => m.result === 'loss').length}</div>
          <div style="font-size:12px;color:#666">Total Losses</div>
        </div>
        <div style="background:linear-gradient(135deg, #007bff15, #007bff05);padding:15px;border-radius:10px;border-left:4px solid #007bff;text-align:center">
          <div style="font-size:20px;font-weight:bold;color:#007bff">${averageScore(history).toFixed(1)}</div>
          <div style="font-size:12px;color:#666">Avg Score</div>
        </div>
        <div style="background:linear-gradient(135deg, #ffc10715, #ffc10705);padding:15px;border-radius:10px;border-left:4px solid #ffc107;text-align:center">
          <div style="font-size:20px;font-weight:bold;color:#ffc107">${longestWinStreak(history)}</div>
          <div style="font-size:12px;color:#666">Best Streak</div>
        </div>
      </div>


      <div style="background:#fff;border-radius:12px;overflow:hidden;box-shadow:0 2px 10px rgba(0,0,0,0.1)">
        <div style="background:#f8f9fa;padding:15px;border-bottom:1px solid #e9ecef">
          <h4 style="margin:0;color:#333">游 Recent Matches</h4>
        </div>
        <div style="max-height:400px;overflow-y:auto">
          ${recent.map(m => {
            const isWin = m.result === 'win';
            const diff = Math.abs(m.user_score - m.opponent_score);
            const type = diff <= 2 ? { label: 'NAIL-BITER', color: '#dc3545' }
              : diff <= 5 ? { label: 'CLOSE', color: '#ffc107' }
              : diff <= 10 ? { label: 'COMPETITIVE', color: '#17a2b8' }
              : { label: 'DOMINANT', color: '#28a745' };
            return `
              <div style="padding:15px;border-bottom:1px solid #f1f3f4;display:flex;align-items:center;gap:15px">
                <div style="width:50px;height:50px;border-radius:50%;display:flex;align-items:center;justify-content:center;background:${isWin ? '#28a745' : '#dc3545'};color:#fff;font-weight:bold;font-size:18px">
                  ${isWin ? '游끥' : '仇'}
                </div>
                <div style="flex:1">
                  <div style="display:flex;align-items:center;gap:10px;margin-bottom:4px">
                    <span style="font-weight:bold;color:#333">vs Player ${m.opponent_id}</span>
                    <span style="background:${type.color};color:#fff;padding:2px 8px;border-radius:12px;font-size:11px;font-weight:bold">${type.label}</span>
                  </div>
                  <div style="font-size:13px;color:#666">${new Date(m.date_played).toLocaleDateString()}  ${new Date(m.date_played).toLocaleTimeString()}</div>
                </div>
                <div style="text-align:right">
                  <div style="font-family:monospace;font-size:18px;font-weight:bold;color:#333">${m.user_score} - ${m.opponent_score}</div>
                  <div style="font-size:12px;color:${isWin ? '#28a745' : '#dc3545'};font-weight:bold">${isWin ? 'VICTORY' : 'DEFEAT'}</div>
                </div>
                <div style="text-align:center;min-width:60px">
                  <div style="font-size:14px;color:#666">낌勇</div>
                  <div style="font-size:12px;color:#666">${m.duration || 'N/A'}</div>
                </div>
              </div>`;
          }).join('')}
        </div>
      </div>
    </div>
  `;
}


export function historyDetailed(history: Match[]): string {
  return `
    <div>
      <div style="background:#f8f9fa;padding:15px;border-radius:8px;margin-bottom:20px">
        <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
          <label style="font-weight:bold;color:#333">Filter:</label>
          <select id="match-filter" style="padding:6px 12px;border:1px solid #ddd;border-radius:4px;background:#fff">
            <option value="all">All Matches</option>
            <option value="wins">Wins Only</option>
            <option value="losses">Losses Only</option>
            <option value="close">Close Games</option>
            <option value="blowouts">Decisive Wins</option>
          </select>
          <select id="time-filter" style="padding:6px 12px;border:1px solid #ddd;border-radius:4px;background:#fff">
            <option value="all">All Time</option>
            <option value="week">This Week</option>
            <option value="month">This Month</option>
            <option value="quarter">Last 3 Months</option>
          </select>
          <button data-action="apply-history-filters" style="background:#007bff;color:#fff;border:none;padding:6px 12px;border-radius:4px;cursor:pointer">游댌 Apply</button>
        </div>
      </div>


      <div id="filtered-matches" style="display:grid;gap:15px">
        ${history.slice(0, 6).map((m, idx) => `
          <div style="background:#fff;border-radius:12px;padding:20px;box-shadow:0 2px 10px rgba(0,0,0,0.1);border-left:5px solid ${m.result === 'win' ? '#28a745' : '#dc3545'}">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px">
              <div style="display:flex;align-items:center;gap:12px">
                <div style="width:40px;height:40px;border-radius:50%;display:flex;align-items:center;justify-content:center;background:${m.result === 'win' ? '#28a745' : '#dc3545'};color:#fff;font-size:16px">
                  ${m.result === 'win' ? '游끥' : '仇'}
                </div>
                <div>
                  <h4 style="margin:0;color:#333">Match #${history.length - idx}</h4>
                  <div style="font-size:13px;color:#666">${new Date(m.date_played).toLocaleString()}</div>
                </div>
              </div>
              <div style="text-align:right">
                <div style="font-family:monospace;font-size:24px;font-weight:bold;color:#333">${m.user_score} - ${m.opponent_score}</div>
                <div style="font-size:12px;color:${m.result === 'win' ? '#28a745' : '#dc3545'};font-weight:bold">${m.result === 'win' ? 'VICTORY' : 'DEFEAT'}</div>
              </div>
            </div>


            <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:15px;margin-bottom:15px">
              <div style="background:#f8f9fa;padding:12px;border-radius:8px">
                <div style="font-size:12px;color:#666;margin-bottom:4px">OPPONENT</div>
                <div style="font-weight:bold;color:#333">Player ${m.opponent_id}</div>
              </div>
              <div style="background:#f8f9fa;padding:12px;border-radius:8px">
                <div style="font-size:12px;color:#666;margin-bottom:4px">DURATION</div>
                <div style="font-weight:bold;color:#333">${m.duration || 'Unknown'}</div>
              </div>
              <div style="background:#f8f9fa;padding:12px;border-radius:8px">
                <div style="font-size:12px;color:#666;margin-bottom:4px">SCORE DIFF</div>
                <div style="font-weight:bold;color:${Math.abs(m.user_score - m.opponent_score) > 5 ? '#dc3545' : '#28a745'}">${Math.abs(m.user_score - m.opponent_score)} pts</div>
              </div>
              <div style="background:#f8f9fa;padding:12px;border-radius:8px">
                <div style="font-size:12px;color:#666;margin-bottom:4px">MATCH TYPE</div>
                <div style="font-weight:bold;color:#333">${
                  Math.abs(m.user_score - m.opponent_score) <= 2 ? 'NAIL-BITER' :
                  Math.abs(m.user_score - m.opponent_score) <= 5 ? 'CLOSE' :
                  Math.abs(m.user_score - m.opponent_score) <= 10 ? 'COMPETITIVE' : 'DOMINANT'
                }</div>
              </div>
            </div>


            <div style="display:flex;gap:10px">
              <button data-action="view-replay" data-id="${m.id}" style="background:#007bff;color:#fff;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;font-size:12px">游닣勇 View Replay</button>
              <button data-action="share-match" data-id="${m.id}" style="background:#28a745;color:#fff;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;font-size:12px">游닋 Share</button>
              <button data-action="analyze-match" data-id="${m.id}" style="background:#ffc107;color:#000;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;font-size:12px">游늵 Analyze</button>
            </div>
          </div>
        `).join('')}
      </div>
    </div>
  `;
}


export function historyAnalysis(history: Match[]): string {
  return `
    <div>
      <div style="background:#f8f9fa;padding:20px;border-radius:12px;margin-bottom:25px">
        <h4 style="margin:0 0 15px 0;color:#333">游늳 Match Performance Analysis</h4>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px">
          <div><canvas id="winRateChart" width="250" height="200" style="width:100%;height:200px;background:#fff;border-radius:8px"></canvas></div>
          <div><canvas id="scoreDistribution" width="250" height="200" style="width:100%;height:200px;background:#fff;border-radius:8px"></canvas></div>
        </div>
      </div>


      <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:25px">
        <div style="background:#fff;padding:20px;border-radius:12px;box-shadow:0 2px 10px rgba(0,0,0,0.1)">
          <h4 style="margin:0 0 15px 0;color:#333">游꿢 Performance Patterns</h4>
          ${[
            { label: 'Best Day', value: bestPlayingDay(history), desc: 'Highest win rate', color: '#28a745' },
            { label: 'Preferred Time', value: mostActiveTime(history), desc: 'Most active period', color: '#007bff' },
            { label: 'Momentum', value: currentMomentum(history), desc: 'Recent trend', color: '#17a2b8' },
          ].map(p => `
            <div style="display:flex;justify-content:space-between;align-items:center;padding:10px;background:#f8f9fa;border-radius:8px;margin-bottom:10px">
              <div><div style="font-weight:bold;color:#333">${p.label}</div><div style="font-size:12px;color:#666">${p.desc}</div></div>
              <div style="font-weight:bold;color:${p.color}">${p.value}</div>
            </div>
          `).join('')}
        </div>


        <div style="background:#fff;padding:20px;border-radius:12px;box-shadow:0 2px 10px rgba(0,0,0,0.1)">
          <h4 style="margin:0 0 15px 0;color:#333">游논 Opponent Analysis</h4>
          ${opponentAnalysis(history).map((o, i) => `
            <div style="display:flex;align-items:center;gap:12px;padding:8px;border-bottom:1px solid #f1f3f4">
              <div style="width:30px;height:30px;border-radius:50%;background:#007bff;color:#fff;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:12px">${i + 1}</div>
              <div style="flex:1">
                <div style="font-weight:bold;color:#333">Player ${o.id}</div>
                <div style="font-size:12px;color:#666">${o.matches} matches</div>
              </div>
              <div style="text-align:right">
                <div style="font-weight:bold;color:${o.winRate >= 50 ? '#28a745' : '#dc3545'}">${o.winRate}%</div>
                <div style="font-size:12px;color:#666">${o.record}</div>
              </div>
            </div>
          `).join('')}
        </div>
      </div>


      <div style="background:#fff;padding:20px;border-radius:12px;box-shadow:0 2px 10px rgba(0,0,0,0.1)">
        <h4 style="margin:0 0 15px 0;color:#333">낋 Time-based Performance</h4>
        <canvas id="timeAnalysisChart" width="800" height="250" style="width:100%;height:250px;background:#f8f9fa;border-radius:8px"></canvas>
      </div>
    </div>
  `;
}


export function modals(): string {
  return `
    <div id="notification" style="display:none;position:fixed;top:20px;right:20px;background:#28a745;color:#fff;padding:15px 20px;border-radius:5px;z-index:1000;max-width:300px"></div>
    <div id="avatar-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.7);justify-content:center;align-items:center;z-index:2000">
      <div style="background:#fff;padding:30px;border-radius:15px;width:600px;max-width:90%;max-height:80vh;overflow-y:auto;box-shadow:0 10px 30px rgba(0,0,0,0.3)">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px">
          <h3 style="margin:0;color:#333;font-size:20px">游뒆勇 Choose Your Avatar</h3>
          <button id="avatar-modal-close" style="background:none;border:none;font-size:24px;cursor:pointer;color:#999;width:30px;height:30px;display:flex;align-items:center;justify-content:center">칑</button>
        </div>
        <p style="color:#666;margin-bottom:20px;font-size:14px">Select an avatar from the options below:</p>
        <div id="avatar-grid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(80px,1fr));gap:12px">
          ${AVAILABLE_AVATARS.map((a, i) => `
            <div class="avatar-option" data-avatar="${a}" style="cursor:pointer;border:3px solid transparent;border-radius:12px;padding:8px;transition:all 0.3s;background:#f8f9fa">
              <img src="${a}" width="64" height="64" style="border-radius:50%;object-fit:cover;display:block;width:100%" alt="Avatar ${i+1}"/>
            </div>
          `).join('')}
        </div>
        <div style="margin-top:20px;text-align:center">
          <button id="avatar-confirm" disabled style="background:#007bff;color:#fff;border:none;padding:12px 24px;border-radius:6px;cursor:pointer;font-size:14px;opacity:0.5">Select Avatar</button>
        </div>
      </div>
    </div>


    <div id="pass-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.5);justify-content:center;align-items:center;z-index:2000">
      <div style="background:#fff;padding:30px;border-radius:10px;width:400px;max-width:90%;box-shadow:0 10px 30px rgba(0,0,0,0.3)">
        <h3 style="margin:0 0 20px 0;color:#333">游 Change Password</h3>
        <form id="pass-form">
          <div style="margin-bottom:15px">
            <label style="display:block;margin-bottom:5px;font-weight:bold">Current Password:</label>
            <input id="pass-cur" type="password" required style="width:100%;padding:10px;border:1px solid #ddd;border-radius:4px;box-sizing:border-box"/>
          </div>
          <div style="margin-bottom:15px">
            <label style="display:block;margin-bottom:5px;font-weight:bold">New Password:</label>
            <input id="pass-new" type="password" minlength="6" required style="width:100%;padding:10px;border:1px solid #ddd;border-radius:4px;box-sizing:border-box"/>
            <small style="color:#666">Minimum 6 characters</small>
          </div>
          <div style="margin-bottom:20px">
            <label style="display:block;margin-bottom:5px;font-weight:bold">Confirm Password:</label>
            <input id="pass-conf" type="password" minlength="6" required style="width:100%;padding:10px;border:1px solid #ddd;border-radius:4px;box-sizing:border-box"/>
          </div>
          <div style="display:flex;justify-content:flex-end;gap:10px">
            <button type="button" id="pass-cancel" style="background:#6c757d;color:#fff;border:none;padding:10px 20px;border-radius:4px;cursor:pointer">Cancel</button>
            <button type="submit" style="background:#007bff;color:#fff;border:none;padding:10px 20px;border-radius:4px;cursor:pointer">Update Password</button>
          </div>
          <div id="pass-error" style="color:#dc3545;margin-top:10px;font-size:14px"></div>
        </form>
      </div>
    </div>
  `;
}


export function layout(profile: Profile, stats: Stats, history: Match[], friends: Friend[], statsTab: string, historyView: string, editMode: boolean): string {
  return `
    <div style="max-width:1400px;margin:0 auto;padding:20px">
      <h2 style="color:#333;border-bottom:3px solid #007bff;padding-bottom:10px;margin-bottom:20px">游녻 Profile Dashboard</h2>
      ${header(profile, editMode)}
      <div style="display:grid;grid-template-columns:2fr 1fr;gap:30px;margin-top:30px">
        <div>
          <div style="background:#fff;border-radius:12px;box-shadow:0 4px 20px rgba(0,0,0,0.1);margin-bottom:30px">
            <div style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);color:#fff;padding:20px;border-radius:12px 12px 0 0">
              <h3 style="margin:0;font-size:20px;display:flex;align-items:center;gap:10px">游늵 Gaming Statistics Dashboard</h3>
              <p style="margin:5px 0 0 0;opacity:0.9;font-size:14px">Comprehensive view of your gaming performance</p>
            </div>
            <div style="display:flex;border-bottom:1px solid #e9ecef;background:#f8f9fa">
              ${['overview','performance','trends'].map(tab => `
                <button class="stats-tab ${statsTab === tab ? 'active' : ''}" data-tab="${tab}"
                        style="flex:1;padding:12px 20px;border:none;background:${statsTab === tab ? '#fff' : 'transparent'};
                               border-bottom:3px solid ${statsTab === tab ? '#007bff' : 'transparent'};
                               cursor:pointer;font-weight:${statsTab === tab ? 'bold' : 'normal'};color:#333">
                  ${tab === 'overview' ? '游늳 Overview' : tab === 'performance' ? '游꿢 Performance' : '游늵 Trends'}
                </button>
              `).join('')}
            </div>
            <div id="stats-content" style="padding:20px"></div>
          </div>


          <div style="background:#fff;border-radius:12px;box-shadow:0 4px 20px rgba(0,0,0,0.1)">
            <div style="background:linear-gradient(135deg, #f093fb 0%, #f5576c 100%);color:#fff;padding:20px;border-radius:12px 12px 0 0">
              <h3 style="margin:0;font-size:20px;display:flex;align-items:center;gap:10px">游끥 Match History Dashboard</h3>
              <p style="margin:5px 0 0 0;opacity:0.9;font-size:14px">Detailed analysis of your game sessions</p>
            </div>
            <div style="display:flex;border-bottom:1px solid #e9ecef;background:#f8f9fa">
              ${['list','detailed','analysis'].map(view => `
                <button class="history-tab ${historyView === view ? 'active' : ''}" data-view="${view}"
                        style="flex:1;padding:12px 20px;border:none;background:${historyView === view ? '#fff' : 'transparent'};
                               border-bottom:3px solid ${historyView === view ? '#f5576c' : 'transparent'};
                               cursor:pointer;font-weight:${historyView === view ? 'bold' : 'normal'};color:#333">
                  ${view === 'list' ? '游늶 Match List' : view === 'detailed' ? '游댌 Detailed View' : '游늳 Analysis'}
                </button>
              `).join('')}
            </div>
            <div id="history-content" style="padding:20px"></div>
          </div>
        </div>


        <div>
          <h3 style="color:#333;border-bottom:2px solid #dc3545;padding-bottom:8px;margin-bottom:15px">游논 Friends</h3>
          <div style="background:#f8f9fa;padding:15px;border-radius:8px;margin-bottom:20px">
            <h4 style="margin:0 0 10px 0;font-size:14px;color:#666">Add New Friend</h4>
            <div style="display:flex;gap:8px">
              <input id="friend-input" placeholder="Enter username..." style="flex:1;padding:8px;border:1px solid #ddd;border-radius:4px;font-size:14px"/>
              <button id="friend-add" style="background:#007bff;color:#fff;border:none;padding:8px 12px;border-radius:4px;cursor:pointer;font-size:14px">俱 Add</button>
            </div>
            <div id="friend-msg" style="margin-top:8px;font-size:12px"></div>
          </div>
          <div id="friends-container">${friendsList(friends)}</div>
        </div>
      </div>


      ${modals()}
    </div>
  `;
}

//renderProfilePage/types.ts
export type Stats = {
  matches_played: number;
  matches_won: number;
  matches_lost: number;
  win_rate: number; // 0..1
  points_scored: number;
  points_conceded: number;
  tournaments_won: number;
};


export type Match = {
  id: string;
  date_played: string; // ISO
  opponent_id: string;
  user_score: number;
  opponent_score: number;
  result: 'win' | 'loss';
  duration?: string;
};


export type Friend = {
  id: string;
  friend_id?: number; // In case the API returns friend_id instead of id
  name?: string;
  username: string;
  display_name: string;
  avatar_url: string;
  team: string;
  last_seen?: string;
  online_status: boolean;
};


export type Profile = {
  id: number;
  username: string;
  display_name?: string;
  name?: string;
  email?: string;
  avatar_url: string;
  team?: string;
  created_at: string;
  last_seen?: string;
  online_status?: boolean;
};


export type StatsTab = 'overview' | 'performance' | 'trends';
export type HistoryView = 'list' | 'detailed' | 'analysis';


export const DEFAULT_STATS: Stats = {
  matches_played: 0,
  matches_won: 0,
  matches_lost: 0,
  win_rate: 0,
  points_scored: 0,
  points_conceded: 0,
  tournaments_won: 0
};


export const AVAILABLE_AVATARS: string[] = [
  '/assets/avatar/default.png',
  '/assets/avatar/Blue_002.png',
  '/assets/avatar/Blue_003.png',
  '/assets/avatar/Blue_004.png',
  '/assets/avatar/Blue_005.png',
  '/assets/avatar/Blue_006.png',
  '/assets/avatar/Blue_007.png',
  '/assets/avatar/Blue_008.png',
  '/assets/avatar/Blue_009.png',
  '/assets/avatar/Blue_010.png',
  '/assets/avatar/Blue_011.png',
  '/assets/avatar/Blue_012.png',
  '/assets/avatar/Blue_013.png',
  '/assets/avatar/Blue_014.png',
  '/assets/avatar/Blue_015.png',
  '/assets/avatar/Blue_016.png',
  '/assets/avatar/Blue_017.png',
  '/assets/avatar/Blue_018.png',
  '/assets/avatar/Blue_019.png',
  '/assets/avatar/Blue_020.png'
];

//services/renderFriendRequestPage.ts
import { updateFriendRequestsBadge } from '../index.js';


export async function renderFriendRequestsPage(container: HTMLElement) {
    const token = localStorage.getItem('authToken');
    if (!token) {
        container.innerHTML = '<p>Please log in to view friend requests.</p>';
        return;
    }


    // 游댠 Initial HTML
    container.innerHTML = `
        <h2>游논 Friend Requests</h2>
        
        <div id="pending-requests" style="margin: 20px 0;">
            <h3>游닌 Pending Requests</h3>
            <div id="pending-list">
                <p>Loading pending requests...</p>
            </div>
        </div>


        <!-- Back to Profile Button -->
        <button id="back-to-profile" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 20px;">
             Back to Profile
        </button>


        <!-- 游댠 NOTIFICATION AREA -->
        <div id="notification" style="display: none; position: fixed; top: 20px; right: 20px; background: #28a745; color: white; padding: 15px; border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); z-index: 1000;"></div>
    `;


    // 游댠 Setup back button
    document.getElementById('back-to-profile')!.addEventListener('click', async () => {
        const { renderProfilePage } = await import('./renderProfilePage/profile.js');
        container.innerHTML = '';
        renderProfilePage(container);
    });


    // 游댠 Load pending requests
    loadPendingRequests(token);
}


// 游댠 Load Pending Requests
async function loadPendingRequests(token: string) {
    try {
        const response = await fetch('/api/friends/pending', {
            headers: { 'Authorization': `Bearer ${token}` }
        });


        if (response.ok) {
            const data = await response.json();
            const pendingRequests = data.pending || [];
            
            if (pendingRequests.length > 0) {
                document.getElementById('pending-list')!.innerHTML = `
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        ${pendingRequests.map((request: any) => `
                            <div class="pending-request" style="display: flex; align-items: center; justify-content: space-between; padding: 15px; border: 1px solid #ddd; border-radius: 8px; background: #f9f9f9;">
                                <div>
                                    <strong>${request.display_name || request.name}</strong> (@${request.username})
                                    <pt><small>Team: ${request.team}</small>
                                    <pt><small>Sent: ${new Date(request.created_at).toLocaleDateString()}</small>
                                </div>
                                <div style="display: flex; gap: 10px;">
                                    <button class="accept-btn" data-friend-id="${request.user_id}" data-friend-name="${request.display_name || request.name}" 
                                            style="background: #28a745; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer;" 
                                            title="Accept friend request">
                                        九 Accept
                                    </button>
                                    <button class="reject-btn" data-friend-id="${request.user_id}" data-friend-name="${request.display_name || request.name}"
                                            style="background: #dc3545; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer;"
                                            title="Reject friend request">
                                        九 Reject
                                    </button>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;


                // 游댠 Setup accept/reject buttons
                setupPendingRequestButtons(token);
            } else {
                document.getElementById('pending-list')!.innerHTML = '<p>No pending friend requests.</p>';
            }
        } else {
            document.getElementById('pending-list')!.innerHTML = '<p>Failed to load pending requests.</p>';
        }
    } catch (error) {
        document.getElementById('pending-list')!.innerHTML = '<p>Error loading requests.</p>';
    }
}


// 游댠 Setup Accept/Reject Buttons
function setupPendingRequestButtons(token: string) {
    // Accept buttons
    document.querySelectorAll('.accept-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
            const friendId = parseInt(btn.getAttribute('data-friend-id')!);
            const friendName = btn.getAttribute('data-friend-name')!;
            
            try {
                const response = await fetch('/api/friends/accept', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({ friendId })
                });


                if (response.ok) {
                    showNotification(`${friendName} foi adicionado aos teus amigos!`, 'success');
                    // Refresh lists
                    loadPendingRequests(token);
                    updateFriendRequestsBadge();
                } else {
                    const result = await response.json();
                    showNotification(result.error || 'Failed to accept request', 'error');
                }
            } catch (error) {
                showNotification('Network error occurred', 'error');
            }
        });
    });


    // Reject buttons
    document.querySelectorAll('.reject-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
            const friendId = parseInt(btn.getAttribute('data-friend-id')!);
            const friendName = btn.getAttribute('data-friend-name')!;
            
            const confirmed = confirm(`Tens a certeza que queres rejeitar o pedido de ${friendName}?`);
            if (!confirmed) return;
            
            try {
                const response = await fetch('/api/friends/reject', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({ friendId })
                });


                if (response.ok) {
                    showNotification(`Pedido de ${friendName} foi rejeitado`, 'success');
                    // Refresh lists
                    loadPendingRequests(token);
                    updateFriendRequestsBadge();
                } else {
                    const result = await response.json();
                    showNotification(result.error || 'Failed to reject request', 'error');
                }
            } catch (error) {
                showNotification('Network error occurred', 'error');
            }
        });
    });
}


// 游댠 Show Notification
function showNotification(message: string, type: 'success' | 'error') {
    const notification = document.getElementById('notification') as HTMLDivElement;
    notification.textContent = message;
    notification.style.backgroundColor = type === 'success' ? '#28a745' : '#dc3545';
    notification.style.display = 'block';
    
    setTimeout(() => {
        notification.style.display = 'none';
    }, 3000);
}

export function renderLoginForm(container: HTMLElement, onLoginSuccess: () => void): void {
  container.innerHTML = `
    <h2>Login</h2>
    <form id="login-form">
      <input type="text" name="username" placeholder="Username" required />
      <input type="password" name="password" placeholder="Password" required />
      <button type="submit">Login</button>
    </form>
    <div id="login-result"></div>
  `;


  const form = document.getElementById('login-form') as HTMLFormElement;
  const resultDiv = document.getElementById('login-result') as HTMLDivElement;


  form.addEventListener('submit', async (e: Event) => {
    e.preventDefault();


    const formData = new FormData(form);
    const data = {
      username: formData.get('username') as string,
      password: formData.get('password') as string,
    };


    try {
      const res = await fetch('https://localhost:3000/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });


      const result = await res.json();
      if (result.token) {
        localStorage.setItem('authToken', result.token);
        resultDiv.textContent = 'Login successful!';
        startActivityMonitoring();
        onLoginSuccess(); // 游녣 Update UI
      } else {
        resultDiv.textContent = 'Invalid credentials.';
      }
    } catch (err) {
      resultDiv.textContent = 'Login failed.';
    }
  });
}


// Activity monitoring system
let activityTimer: ReturnType<typeof setTimeout>;
let isUserActive = true;


export function startActivityMonitoring() {


    updateOnlineStatus(true); // Set online on start
    
    const ACTIVITY_TIMEOUT = 5 * 60 * 1000; // 5 minutes
    const UPDATE_INTERVAL = 30 * 1000; // 30 seconds


    // Reset activity timer
    function resetActivityTimer() {
        clearTimeout(activityTimer);
        if (!isUserActive) {
            isUserActive = true;
            updateOnlineStatus(true);
        }
        
        activityTimer = setTimeout(() => {
            isUserActive = false;
            updateOnlineStatus(false);
        }, ACTIVITY_TIMEOUT);
    }


    // Track user activities
    const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];
    events.forEach(event => {
        document.addEventListener(event, resetActivityTimer, true);
    });


    // Update last_seen periodically
    setInterval(() => {
        if (isUserActive) {
            updateLastSeen();
        }
    }, UPDATE_INTERVAL);


    // Handle page visibility
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            updateOnlineStatus(false);
        } else {
            resetActivityTimer();
        }
    });


    // Handle beforeunload (user closing browser/tab)
    window.addEventListener('beforeunload', () => {
        updateOnlineStatus(false);
    });


    // Start the timer
    resetActivityTimer();
}


async function updateOnlineStatus(isOnline: boolean) {
    const token = localStorage.getItem('authToken');
    if (!token) return;


    try {
        await fetch('/api/profile/status', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({ online: isOnline })
        });
        console.log(`Status updated to: ${isOnline ? 'online' : 'offline'}`);
    } catch (error) {
        console.error('Failed to update status:', error);
    }
}


async function updateLastSeen() {
    const token = localStorage.getItem('authToken');
    if (!token) return;


    try {
        await fetch('/api/profile/update-last-seen', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            }
        });
    } catch (error) {
        console.error('Failed to update last seen:', error);
    }
}

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pong Game</title>
</head>
<body>
  <h1>PONG!!!!</h1>


  <!-- Buttons hidden by default unless login state is valid -->
  <button id="play-btn" style="display: none;">Play</button>
  <button id="settings-btn" style="display: none;">Player Settings</button>
  <button id="tournaments-btn" style="display: none;">Tournaments</button>
  <button id="teams-btn" style="display: none;">Teams</button>


  <!-- Auth buttons -->
  <button id="login-btn">Login</button>
  <button id="register-btn">Register</button>
  <button id="logout-btn" style="display: none;">Logout</button>
  <button id="profile-btn" style="display: none;">Profile</button>


  <!-- 游댠 FRIEND REQUESTS NOTIFICATION -->
  <button id="friend-requests-btn" style="display: none; position: relative; background: #28a745; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer;">
    游닎 Friend Requests
    <span id="friend-requests-badge" style="display: none; position: absolute; top: -5px; right: -5px; background: red; color: white; border-radius: 50%; width: 20px; height: 20px; font-size: 12px; text-align: center; line-height: 20px;"></span>
  </button>


  <div id="app"></div>


  <script type="module" src="index.js"></script>
</body>
</html>

import { renderPlayMenu } from './services/renderPlayMenu.js';
import { renderSettingsPage } from './services/settings.js';
import { renderTournamentsPage } from './services/tournaments.js';
import { renderTeamsPage } from './services/teams.js';
import { renderRegistrationForm } from './services/renderRegistrationForm.js';
import { renderLoginForm, startActivityMonitoring } from './services/renderLoginForm.js';
import { renderProfilePage } from './services/renderProfilePage/profile.js';
import { renderFriendRequestsPage } from './services/renderFriendRequestPage.js';


// Button references
const playBtn = document.getElementById('play-btn') as HTMLButtonElement;
const settingsBtn = document.getElementById('settings-btn') as HTMLButtonElement;
const tournamentsBtn = document.getElementById('tournaments-btn') as HTMLButtonElement;
const teamsBtn = document.getElementById('teams-btn') as HTMLButtonElement;
const loginBtn = document.getElementById('login-btn') as HTMLButtonElement;
const logoutBtn = document.getElementById('logout-btn') as HTMLButtonElement;
const registerBtn = document.getElementById('register-btn') as HTMLButtonElement;
const profileBtn = document.getElementById('profile-btn') as HTMLButtonElement;
const friendRequestsBtn = document.getElementById('friend-requests-btn') as HTMLButtonElement;
const friendRequestsBadge = document.getElementById('friend-requests-badge') as HTMLSpanElement;


const appDiv = document.getElementById('app') as HTMLDivElement;


// 游댃 Update UI based on login state
function updateUIBasedOnAuth(): void {
  const token = localStorage.getItem('authToken');
  const isLoggedIn = !!token;


  playBtn.style.display = isLoggedIn ? 'inline-block' : 'none';
  settingsBtn.style.display = isLoggedIn ? 'inline-block' : 'none';
  tournamentsBtn.style.display = isLoggedIn ? 'inline-block' : 'none';
  teamsBtn.style.display = isLoggedIn ? 'inline-block' : 'none';
  logoutBtn.style.display = isLoggedIn ? 'inline-block' : 'none';
  profileBtn.style.display = isLoggedIn ? 'inline-block' : 'none';


  loginBtn.style.display = isLoggedIn ? 'none' : 'inline-block';
  registerBtn.style.display = isLoggedIn ? 'none' : 'inline-block';


  friendRequestsBtn.style.display = isLoggedIn ? 'inline-block' : 'none';
  if (isLoggedIn) {
      updateFriendRequestsBadge();
      setOnlineOnLoad();
  }
}


// 游 Event Listeners
playBtn.addEventListener('click', () => {
  appDiv.innerHTML = '';
  renderPlayMenu(appDiv);
});


settingsBtn.addEventListener('click', () => {
  appDiv.innerHTML = '';
  renderSettingsPage(appDiv);
});


tournamentsBtn.addEventListener('click', () => {
  appDiv.innerHTML = '';
  renderTournamentsPage(appDiv);
});


teamsBtn.addEventListener('click', () => {
  appDiv.innerHTML = '';
  renderTeamsPage(appDiv);
});


loginBtn.addEventListener('click', () => {
  appDiv.innerHTML = '';
  renderLoginForm(appDiv, updateUIBasedOnAuth);
});


registerBtn.addEventListener('click', () => {
  appDiv.innerHTML = '';
  renderRegistrationForm(appDiv);
});


logoutBtn.addEventListener('click', async () => {
  // Update status to offline before logout
  const token = localStorage.getItem('authToken');
  if (token) {
      try {
          await fetch('/api/profile/status', {
              method: 'POST',
              headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${token}`
              },
              body: JSON.stringify({ online: false })
          });
      } catch (error) {
          console.error('Failed to update status on logout:', error);
      }
  }
  
  localStorage.removeItem('authToken');
  appDiv.innerHTML = '<p>You have been logged out.</p>';
  updateUIBasedOnAuth();
  
  // Clean up activity monitoring
  document.removeEventListener('visibilitychange', () => {});
  window.removeEventListener('beforeunload', () => {});
});


profileBtn.addEventListener('click', () => {
  appDiv.innerHTML = '';
  renderProfilePage(appDiv);
});


// Update friend requests badge
export async function updateFriendRequestsBadge() {
  const token = localStorage.getItem('authToken');
  if (!token) return;
  
  try {
      const response = await fetch('/api/friends/pending', {
          headers: { 'Authorization': `Bearer ${token}` }
      });
      
      if (response.ok) {
          const data = await response.json();
          const pendingCount = data.pending?.length || 0;
          
          if (pendingCount > 0) {
              friendRequestsBadge.textContent = pendingCount.toString();
              friendRequestsBadge.style.display = 'block';
          } else {
              friendRequestsBadge.style.display = 'none';
          }
      }
  } catch (error) {
      console.error('Error updating friend requests badge:', error);
  }
}


// Friend requests button event listener
friendRequestsBtn.addEventListener('click', () => {
  appDiv.innerHTML = '';
  renderFriendRequestsPage(appDiv);
});


// 游 Initialize UI
updateUIBasedOnAuth();



// In index.ts - replace the DOMContentLoaded section
document.addEventListener('DOMContentLoaded', async () => {
  const token = localStorage.getItem('authToken');
  if (token) {
    // Verify token is still valid
    try {
      const response = await fetch('/api/protected', {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      
      if (response.ok) {
        // Token is valid, start activity monitoring
        const { startActivityMonitoring } = await import('./services/renderLoginForm.js');
        startActivityMonitoring();
        
        // Set user as online
        await updateOnlineStatus(true);
        
        // Update friend requests badge
        updateFriendRequestsBadge();
      } else {
        // Token is invalid, remove it
        localStorage.removeItem('authToken');
        updateUIBasedOnAuth();
      }
    } catch (error) {
      console.error('Error verifying token on page load:', error);
      localStorage.removeItem('authToken');
      updateUIBasedOnAuth();
    }
  }
});


// Add this helper function to index.ts
async function updateOnlineStatus(isOnline: boolean) {
  const token = localStorage.getItem('authToken');
  if (!token) return;


  try {
    await fetch('/api/profile/status', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({ online: isOnline })
    });
    console.log(`Status updated to: ${isOnline ? 'online' : 'offline'}`);
  } catch (error) {
    console.error('Failed to update status:', error);
  }
}


async function setOnlineOnLoad() {
  const token = localStorage.getItem('authToken');
  if (!token) return;
  try {
    await fetch('/api/profile/status', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({ online: true })
    });
  } catch (err) {
    console.error('Failed to set online on load:', err);
  }
}

melmel@melmel:~/ft_transcendence$ ls -R srcs/frontend/ srcs/backend/
srcs/backend/:
backend.txt  config  db  models  routes  server.ts  services  types  utils
srcs/backend/config:
configs.txt
srcs/backend/db:
database.ts
srcs/backend/models:
models.txt
srcs/backend/routes:
authRoutes.ts     matchHistoryRoutes.ts  teamRoutes.ts         user.ts
friendsRoutes.ts  routes.txt             tournamentRoutes.ts
gameRoutes.ts     statsRoutes.ts         userProfileRoutes.ts
srcs/backend/services:
authService.ts     matchHistoryService.ts  statsService.ts        userProfileService.ts
friendsService.ts  services.ts             teamService.ts         usersService.ts
gameService.ts     services.txt            tournamentsService.ts  userStatsService.ts
srcs/backend/types:
fastify-static.d.ts  game.ts          session.ts  tournament.ts  user.ts
friendship.ts        matchHistory.ts  team.ts     userStats.ts
srcs/backend/utils:
utils.txt
srcs/frontend/:
assets  components  frontend.txt  pages  utils
srcs/frontend/assets:
assets.txt  avatar  bugbusters.png  codealliance.png  hacktivists.png  logicleague.png
srcs/frontend/assets/avatar:
Blue_002.png  Blue_006.png  Blue_010.png  Blue_014.png  Blue_018.png
Blue_003.png  Blue_007.png  Blue_011.png  Blue_015.png  Blue_019.png
Blue_004.png  Blue_008.png  Blue_012.png  Blue_016.png  Blue_020.png
Blue_005.png  Blue_009.png  Blue_013.png  Blue_017.png  default.png
srcs/frontend/components:
components.txt
srcs/frontend/pages:
index.html  index.ts  pages.txt  services
srcs/frontend/pages/services:
renderFriendRequestPage.ts  renderPlayMenu.ts          settings.ts
renderGame                  renderProfilePage          teamStats.ts
renderLoginForm.ts          renderRegistrationForm.ts  teams.ts
renderPlayerSelection.ts    services.txt               tournaments.ts
srcs/frontend/pages/services/renderGame:
endGame.ts     gameControls.ts  gameLoop.ts     renderGame.ts  types.ts
gameCanvas.ts  gameLogic.ts     renderFrame.ts  setupGame.ts
srcs/frontend/pages/services/renderProfilePage:
api.ts  charts.ts  events.ts  metrics.ts  profile.ts  state.ts  templates.ts  types.ts
srcs/frontend/utils:
utils.txt
melmel@melmel:~/ft_transcendence$
